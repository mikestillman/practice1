# @configure_input@
include ../../include/config.Makefile
VPATH = @srcdir@
DEPENDS = yes
############################## main targets
all :: tokens_stub.o
all :: gc_tested
all :: tags
all :: compat.h
all :: ../bin/M2$(EXE)

gc_tested: gc_test; ./$<; touch $@
clean ::; rm -f gc_tested gc_test

## standard options

M2_LDFLAGS := $(LDFLAGS)
M2_LOADLIBES := $(LOADLIBES)
M2_LDLIBS := $(LDLIBS)
LOADLIBES += -lgc

## files

M2_OBJECTS :=
CFILES :=
OPTCFILES := 
EXTRACFILES :=
MADECFILES :=
SRCFILES := 

## engine object files
EFILES := ../e/*.o
# EFILES += ../e/rings/*.o 
EFILES += ../e/linalgGB/*.o

## *.c files

# we want M2inits1 to be first on the command line
M2_OBJECTS = M2inits1.o

OPTCFILES += debug.c
ifeq "$(DEBUG)" "yes"
M2_OBJECTS += debug.o
endif

OPTCFILES += M2inits1.c M2inits2.c
CFILES += M2inits.c M2types.c M2mem.c scclib.c M2lib.c gmp_aux.c memdebug.c gdbm_interface.c 
CFILES += factory_allocator.c
SRCFILES += $(OPTCFILES) $(CFILES)
M2_OBJECTS += $(CFILES:.c=.o)

## *.c files, non source, made by us from other files

MADECFILES := tmp_init.c startup.c
M2_OBJECTS += $(MADECFILES:.c=.o)

# other *.o files
M2_OBJECTS += ../regex/regex.o

## *.cc files

CCFILES := version.cc gmp_init.cc
M2_OBJECTS += $(CCFILES:.cc=.o)
SRCFILES += $(CCFILES)

## *.h files

HFILES := M2types.h getpagesize.h memdebug.h types.h
SRCFILES += $(HFILES)

## *.d files
## the names on these lines should be in sequence from most dependent to least dependent so that "make" can remake the *.dep makefiles

DFILES := 
DFILES += interp.d
DFILES += texmacs.d
DFILES += interface.d
DFILES += actors5.d actors4.d actors3.d actors2.d actors.d
DFILES += evaluate.d libfac.d
DFILES += objects.d
DFILES += struct.d
DFILES += GC.d
DFILES += util.d
DFILES += common.d
DFILES += convertr.d basic.d binding.d
DFILES += parser.d lex.d tokens.d
DFILES += engine.d
DFILES += gmp.d
DFILES += err.d
DFILES += stdiop.d
DFILES += getline.d
DFILES += ctype.d
DFILES += stdio.d
DFILES += nets.d
DFILES += vararray.d
DFILES += varstrin.d
DFILES += strings.d 
DFILES += system.d
DFILES += C.d

actors4.oo basic.oo engine.oo interface.oo objects.oo : ../e/engine.h

M2_OBJECTS += $(DFILES:.d=.oo) 
SRCFILES += $(DFILES)
clean::; rm -f $(DFILES:.d=.c)

############################## dependencies
ifeq "$(DEPENDS)" "yes"
include $(DFILES:.d=.dep)
endif
############################## rules
SCC1 := ../c/scc1
.SUFFIXES: .d .sig .dep .res .test .m2
.PHONY : clean all check tags

SCCFLAGS =

ifeq "$(OPTIMIZE)" "yes"
SCCFLAGS += -O
endif

ifeq "$(GCC)" "no"
SCCFLAGS += -nogcc
endif

%.dep : %.d
	$(SCC1) -dep -J. $<
	mv $*.dp $*.dep
	../util/update $*.sg $*.sig
%.c   : %.d
	$(SCC1) $(SCCFLAGS) +gc -J. -noline $<
%.oo  : %.d
	$(SCC1) $(SCCFLAGS) +gc -J. $<
	$(COMPILE.c) -Wno-unused -Wno-uninitialized $*.c $(OUTPUT_OPTION)
	rm $*.c

CPPFLAGS += -I../../include
CPPFLAGS += -I@srcdir@
CPPFLAGS += -I.
CPPFLAGS += -I../util
CPPFLAGS += -I../e
CPPFLAGS += -I@srcdir@/../regex

CFLAGS += $(DEBUGFLAGS)
# CFLAGS += -Wall -Wshadow -Wcast-qual 
CXXFLAGS += $(WARNINGS)
CFLAGS += -Wno-unused-label

ifeq (gcc,$(CC))
ifeq (yes,$(shell if gcc -Wl,-v 2>&1 | grep -q 'GNU ld' ; then echo yes ; else echo no ; fi))
ifeq ($(MAPFILE),yes)
## - use this to get a memory map listing from the gnu linker
M2_LDFLAGS  += -Wl,-Map,mapfile
endif
endif
endif

ifeq "$(STATIC)" "yes"
M2_LDFLAGS += -Wl,-Bstatic
ifeq ($(OS),Linux)
# this is for gc somehow, see the end of gc/config.h
M2_LDFLAGS += -Wl,-defsym,_DYNAMIC=0
endif
endif

ifeq ($(OS),SunOS)
M2_LOADLIBES += -lsocket -lnsl
endif

clean::; rm -f compat.c compat.h
compat.c compat.h : configure ../../include/config.h
	FLAGS="$(M2_LDFLAGS) $(M2_LOADLIBES) $(M2_LDLIBS)" @srcdir@/configure

M2types.o : M2types.h
M2lib.o scclib.o : compat.h ../c/compat.h ../c/compat.c types.h memdebug.h
gmp_int.o M2lib.o scclib.o gdbm_interface.o gc_cpp.o version.o M2inits.o debug.o : ../../include/config.h
memdebug.o scclib.o actors5.o : memdebug.h

clean::; rm -f startup.c
SSTRING := -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/'
layout.m2 : ../../include/config.Makefile
	(echo '--layout.m2'; echo 'if class LAYOUT === Symbol then LAYOUT = hashTable $(LAYOUT)' ) | sed 's/,/,%     /g' | tr % '\n' >$@
startup.c : ../m2/startup.m2 layout.m2
	(echo 'char startupString1[] =' ; \
	 cat layout.m2 | sed $(SSTRING) ; \
	 echo ';' ; \
	 echo 'char startupString2[] =' ; \
	 cat $< | sed $(SSTRING) ; \
	 echo ';' \
        ) >$@
clean :: ; rm -f layout.m2 startup.c

ifeq "$(DUMPDATA)" "yes"
M2_LDFLAGS += -L../dumpdata
LIBRARYDEPS += ../dumpdata/libdump.a
LIBRARYOPTIONS += -ldump
endif

ifeq ($(OS),SunOS)
# We use mmap in loaddata(), but if it's dynamically loaded, it may stop working as our mapped
# data covers up the jump tables it uses.  I think.
M2_OBJECTS += mmap.o
mmap.o : /usr/lib/libc.a; ar x $^ $@
endif

tmp_init.o : tmp_init.c
clean::; rm -f tmp_init.c
tmp_init.c : $(DFILES)
	../util/timestmp >tmp
	for i in $(DFILES:.d=) ; do echo "void $${i}__prepare();" ; done >>tmp
	echo 'char current_date[] = __DATE__;' >>tmp
	echo 'char current_time[] = __TIME__;' >>tmp
	echo 'int main_inits() {' >>tmp
	for i in $(DFILES:.d=) ; do echo "   $${i}__prepare();" ; done >>tmp
	echo '   return 0;}' >>tmp
	mv tmp tmp_init.c

###################### libraries

ifeq "$(FACTORY)" "yes"

LIBRARYDEPS    += M2_setup.o
LIBRARYOPTIONS += M2_setup.o
LIBRARYOPTIONS += factory_setup.o

# singular libraries: factory, libfac, ntl

ifeq "$(PROFILE)" "yes"
ifeq "$(HAVE_LIBFAC_PG)" "yes"
LIBRARYOPTIONS += -lfac-pg
else
LIBRARYOPTIONS += -lfac
endif
else
LIBRARYOPTIONS += -lfac
endif

# note: linking with libcfmem.a, which provides some replacements for operator new and delete,
# leads to bugs when more recent code uses yet another flavor of operator new, such as
#   operator new (unsigned, std::nothrow),
# which is defined in 
#		include <new>
# So we've decided *not* to link with it.

## rhodium% nm -o --demangle /capybara/lib/libcfmem.a | grep newdelete.o
## /capybara/lib/libcfmem.a:newdelete.o:00000040 T operator delete[](void*)
## /capybara/lib/libcfmem.a:newdelete.o:00000010 T operator delete(void*)
## /capybara/lib/libcfmem.a:newdelete.o:00000030 T operator new[](unsigned int)
## /capybara/lib/libcfmem.a:newdelete.o:00000000 T operator new(unsigned int)
## /capybara/lib/libcfmem.a:newdelete.o:         U freeBlock
## /capybara/lib/libcfmem.a:newdelete.o:         U getBlock

ifeq "$(PROFILE)" "yes"
ifeq "$(HAVE_LIBCF_PG)" "yes"
LIBRARYOPTIONS += -lcf-pg
else
LIBRARYOPTIONS += -lcf
endif
else
LIBRARYOPTIONS += -lcf
endif

LIBRARYDEPS    += factory_setup.o
LIBRARYOPTIONS += factory_setup.o
LIBRARYOPTIONS += M2_setup.o

ifeq "$(PROFILE)" "yes"
ifeq "$(HAVE_LIBNTL_PG)" "yes"
LIBRARYOPTIONS += -lntl-pg
else
LIBRARYOPTIONS += -lntl
endif
else
LIBRARYOPTIONS += -lntl
endif

endif

LIBRARYOPTIONS += $(LAPACKLIBS)

## We put M2inits2.o here so (on some machines) its constructor gets run first, before those of libcf and libntl, placed above.
## This assumes that that 'ld' (the linker) runs the constructors in reverse order -- those rightmost on the command line are run first.
## (To cover all bases, we put M2inits1.o at the left end of the link command line.)
LIBRARYOPTIONS += M2inits2.o
LIBRARYDEPS   += M2inits2.o

ifeq "$(PROFILE)" "yes"
ifeq "$(HAVE_LIBGMP_PG)" "yes"
LIBRARYOPTIONS += -lgmp-pg
else
LIBRARYOPTIONS += -lgmp
endif
else
LIBRARYOPTIONS += -lgmp
endif

ifeq "$(PROFILE)" "yes"
ifeq "$(HAVE_LIBGC_PG)" "yes"
LIBRARYOPTIONS += -lgc-pg
else
LIBRARYOPTIONS += -lgc
endif
else
LIBRARYOPTIONS += -lgc
endif

LIBRARYOPTIONS += -lgdbm

# LIBRARYOPTIONS += $(M2_LDLIBS)

ifeq "$(STATIC)" "yes"
LIBRARYOPTIONS += -Wl,-Bdynamic
endif

ifeq ($(OS),Darwin)
LIBRARYOPTIONS += -lreadline -lhistory
else
LIBRARYOPTIONS += -lreadline -lhistory -lcurses
endif

# we successfully avoid using streamio, but we need the personality function in libstc++
LIBRARYOPTIONS += -lstdc++

LIBRARYOPTIONS += -lm
LIBRARYOPTIONS += -ldl

# I added this line to make static linking work under linux...
LIBRARYOPTIONS += -lpthread

M2_LOADLIBES := $(LIBRARYOPTIONS) $(M2_LOADLIBES)
LINK_OUTPUT_OPTION = $(OUTPUT_OPTION)

# maybe every system now has all the unix routines we use:
# M2_LDLIBS += -lc ../compat/compat.a

clean::; rm -f ../bin/M2$(EXE)
../bin/M2$(EXE) : $(M2_OBJECTS) main.o $(LIBRARYDEPS) $(EFILES)
	time $(CC) $(M2_LDFLAGS) $(M2_OBJECTS) main.o $(EFILES) $(M2_LOADLIBES) -o "$@".tmp
	$(STRIPCMD) "$@".tmp
	mv "$@".tmp "$@"

mapfile.demangled : mapfile ; demangle <$< >$@
clean::; rm -f mapfile.demangled

interpret.a : $(M2_OBJECTS); $(AR) rcs $@ $^
ifeq "$(XCODE)" "yes"
# Mike uses Xcode, an IDE, under MacOS 10 to link against
all :: interpret.a
endif

# just for testing scc stuff
t_main.o : types.h
t : t_main.o gmp.oo stdio.oo strings.oo system.oo C.o t.o; $(CC) $(M2_LDFLAGS) $^ $(M2_LOADLIBES) $(M2_LDLIBS) $(OUTPUT_OPTION)

tags: @srcdir@/TAGS
clean::; rm -f TAGS @srcdir@/TAGS
@srcdir@/TAGS: Makefile $(SRCFILES)
	cd @srcdir@ && etags $(shell ../util/echoout -r $(SRCFILES))

clean ::; rm -f *.log a.out *.o *.sym *.a *.oo *.sig *.sg *.dep *.dp core gmon.out mapfile restart.tmp
distclean : clean; rm -f Makefile
Makefile : Makefile.in; cd ../..; ./config.status Macaulay2/d/Makefile
all :: .gdbinit
.gdbinit:; if [ -f @srcdir@/.gdbinit.$(USER) ]; then cp @srcdir@/.gdbinit.$(USER) $@; fi
clean::; rm -f .gdbinit

# Local Variables:
# compile-command: "make -C $M2BUILDDIR/Macaulay2/d "
# End:
