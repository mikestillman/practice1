The files *.d in this directory are written in a simple language designed to
be almost type-safe.  It handles memory allocation of data structures, and
insists that every variable and every field of a data structure get
initialized.  It treats null pointers as a separate data type, and doesn't
allow dereferencing a pointer that might be null.

-----------------------------------------------------------------------------

But the language is not safe yet!  The main problem is what to do about
calling a function that has not been defined yet, especially if that function
uses global pointer variable that have not been initialized yet.  Here is an
example of code that can make it crash.

	ttt := {i:int};	      -- declare data structure ttt
	ggg():ttt;	      -- forward reference
	xxx := ggg();         -- global variable with initializer
	ggg():ttt := xxx;     -- try to use xxx

We are not interested in developing this language further.

-----------------------------------------------------------------------------
change log

	the translator now emits makefiles named *.dep to show
		the dependence of *.d files on *.sig files.
	always run make twice before giving up on mysterious errors, 
		as the first time, the translator may correct an erroneous
		*.dep file or *.sig file.
	take out statements of the form foo:type; and foo:type:=...;
	or(a,b) is replace by a or b
	put or-type declarations AFTER the declarations of the component parts
	typecase is replaced by when ... is ... do ... is ... do ... else ...
		(we also need predicates for type)
	break() is now break
	provide(x) is now provide x

brief outline of documentation

files
	scc	the shell script that controls the translator, options
		just as for cc
		other options:
			-v		verbose - print command lines used
			-noinit		don't use initial internal definitions
			-tabwidth n	set tab width for source file (affects
					column number in error messages)
			-noarraychks	turn off array bounds checking
			-nogcc		produce cc style c code
			-noansi		produce old style c code
			-memstats	turn off memory allocation stats
			-yydebug	print parse actions
			-debug		produce *.out, *.log, *.sym files
			-O		send -O2 to gcc and implies
					-noarraychks and -memstats
	scc1	the translator
	*.d	source file
	*.sig	signature file produced from *.d by translator
		Needed for "use" statements.
	*.dc	C file produced from *.d by translator
	*.do	object file produced from *.d by translator
	*.out	internal representation of the parsed source code
	*.log	internal representation of the C code produced
	*.sym	symbol table, type list, string table
packages
	Each *.d file is a package whose name is the base name of the file.
	Packages can be explicitly coded with
		package foo ( ... )
	where ... represents the code in the package.  Use "export" on a
	definition statement to export a definition.  Packages can be nested.
	Use
		use foo;
	to open a package for use.  The exported variables, types, and 
	functions are available to the end of the current scope.
Types:
	int, double, long, short,
	bool, char, float, uint, ulong,
	uchar, ushort,
	package, void, null
	function(t,u,v):w
	array(t)			arrays of elements of type t
	array(t,4)			arrays of elements of type t, length 4
	{a:t, b:u, ...}			object with component names a,b,... and types t,u,...
	t or u or ...			union type with members of types 
Expressions:
	(e)				parentheses
	(e;f;...;g)			begin block, returns value of g
	(e;f;...;g;)			begin block, returns nothing
	t(a,b,c)			construct an object/array of type t
					with initial values a,b,c
	null()				a new null pointer (really (void *)0)
	self				the object currently under 
					construction, as in t(a,b,self).
					(what about doubly recursive constructions?)
	t(x)				cast x to type t
	x.a				select component a of object x
	x.i				select i-th member of array x
	refs(x)				number of references to an object x
	length(x)			length of array x
	sizeof(x)			size of object x in bytes
	a:t				declares a to have type t
	a = b				assignment (after declaration)
	a := b				Declaration with initial value
	a:t := b			... with type t explicit
	f(x:t,y:v):w := e		function declaration (with overloading)
	(x:t << y:u):w := e		infix operator declaration
	(- x:t):w := e			prefix operator declaration
	a ::= b				secret stuff
	op<<				operator as identifier
	if a then b else c
	if a then b
	until a do b
	while a do b			evaluates b as long as a is true
	while a list b			produces a list of the values of b, as long as a is true
	foreach a in b do c		
	foreach a at i in b do c
	foreach a at i in b by s do c
	foreach a in b by s do c
		-- warning: assignment to the variable 'a' in these 'foreach'
		-- commands replaces the entry in the array!  Do we want to
		-- change this feature?
	for n do e
	for i to n do e
	for i from m to n do e
	for i from m to n by s do e
	return ()
	return (e)
	break
	new t len n do e			array initialization
	new t len n at i do e			array initialization
	provide x				provide another element
						of array within body of array
						initialization
	import a
	export a := b
	f(x,y)					function application
	f(x,y -- z,w -- t,u,v)			becomes f(x,y,f(z,w,f(t,u,v)))
	when e 					examine e
	  is x:t do f				  if type t, assign to x, do f
	  is v   do h				  if type v, do h
	  else      i				  else do i
	Ccode(t,a,b,c,d)			has type t, inserts a,b,c,d
						into generated C code.  See
						readfile.c for examples.
	!=					unequal
	==					equal (as references, shallow)
	true
	false

Useful functions
	accountfor(i)				account for one eternal object
						occupying i bytes
	exit(i)
	!					not
	|					or
	&					and
	>>					right shift
	<<					left shift, io, etc
	<	>	<=	>=
	+	-	*	/	%
	^					power (for doubles)
	::					nothing

Constants
	"asdf"					string
	'a'					char
	0xabcd					hex format int
	1234					int
	12.34					double

Caveats
	a.1					a syntax error
	a. 1					first element of array a
	a .1					another syntax error
	a . 1					first element of array a
