-- Mike's to do list, new version, started 3/29/04

random aspects of resolutions and GB's:
       matrices returned should NEVER be able to be changed by the computation.
       text_out, stats should maybe function for all these computations.
       quotients, skew commutative, Weyl: all needs to be done or checked.
       DONE (I think): Schreyer order for GB's
       DONE: HF code
       DONE: HF use in resolutions: this I think was not correct
       MAYBE: Frank Schreyer's suggestions
       AT SOME POINT: minimalization routine for resolutions (over fraction rings, ZZ, 
         inhomog, etc).
       gb2: computation completion conditions are not used, except for degree...

routines to implement: gin, lexideal, macaulayRep, noetherNormalization, routines for
points, toric rings, LPP, what else?

pushforward, pushforward1 should be stashed too, and should work functorially and with 
inhomogeneous maps and modules.

subring, quotient, and saturation computations need to be interruptable: so we must
stash the results.

factorization and decomposition from singular needs to be interruptable.

Groebner bases todo: HF use, mingens, subring elements, elements sorted in 
decreasing monomial order?

random matrices of scalars

skew multiplication: does it still work?  Get it working, test it.

leadTerm needs to be made to work again

basis needs to be made to work again

basis needs to be functorial

rawMonomials needs to be connected to front end (this is the new version which 
takes a matrix instead a list of exponent vectors)

Monomial orders for free modules should obey what we agreed with Cox

Add GroupRevLex to monomial order creation routines

Get resolutions back up and running

Get quotient rings functional: this includes getting fraction rings functional,
  and polynomial rings over that.  This includes having various routines
  like leadCoefficient do the right thing.

DONE Polynomial rings should take a degree ring instead of a degree monoid.  Then we need a
way of specifying the trivial ring.

Go back to having a MutableMatrix class, which does not have free module information.
All mutable operations must be switched back.  Need a routine: map(Module,Module,MutableMatrix)
  - Write the remaining mutable matrix operations.
  - Change the interface to some of the rawMatrix commands.
How does this interact with lapack matrices?

statistics routine for Computation
  summary or stats for a computation should be in the toString.
  -- rawSummary(computation)


 term over position (TOP) :

       e_1 < e_2 < ... (bottom down, top up)

	    R = ZZ[x,y,z]
	    R = ZZ[x,y,z, MonomialOrder => GRevLex ]
	    R = ZZ[x,y,z, MonomialOrder => { GRevLex } ]
	    R = ZZ[x,y,z, MonomialOrder => { GRevLex, Position } ]
	    R = ZZ[x,y,z, MonomialOrder => { GRevLex, Position => Up} ]

       e_1 > e_2 > ... (top down, bottom up)

	    R = ZZ[x,y,z, MonomialOrder => { GRevLex, Position => Down } ]

    position over term (POT) :

       e_1 < e_2 < ... (bottom down, top up)

	    R = ZZ[x,y,z, MonomialOrder => Position ]
	    R = ZZ[x,y,z, MonomialOrder => { Position } ]
	    R = ZZ[x,y,z, MonomialOrder => { Position, GRevLex } ]
	    R = ZZ[x,y,z, MonomialOrder => { Position => Up} ]
	    R = ZZ[x,y,z, MonomialOrder => { Position => Up, GRevLex} ]

       e_1 > e_2 > ... (top down, bottom up)

	    R = ZZ[x,y,z, MonomialOrder => { Position => Down } ]
	    R = ZZ[x,y,z, MonomialOrder => { Position => Down, GRevLex } ]

    Many other ordering keywords can replace or supplement GRevLex:

	    GRevLex => 3	     (order just 3 variables this way)
	    Lex
	    Lex => 3
	    RevLex
	    RevLex => 3
	    Eliminate 3
	    ProductOrder {...}
	    GroupLex
	    NCLex
	    ...

 Dear Dan: Up and Down are great.  The example we do using Macaulay 2 is 
   the following very simple computation:

   R = QQ[a..d, MonomialOrder => {Position => Down}]

   M = matrix{{a2+b2, a3 - 2*b*c*d, a - b},{c2 - d2, b3 + a*c*d, c+d}}

   gens gb M

   The answer appears as equation (2.10) on page 205 of Using Algebraic 
   Geometry.  We also do this example in Singular (and, in the 2nd edition, 
   also in Maple).  In all three computations, we use TOP downward grevlex. 
     It would be wonderful if you could check this in Macaulay 2.  
       Many thanks, David
