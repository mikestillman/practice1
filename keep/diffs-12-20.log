diff -c ./Makefile.secondary /home2/mike/src/M/Macaulay2-0.8.12/e/Makefile.secondary
*** ./Makefile.secondary	Thu Apr 17 19:12:39 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/Makefile.secondary	Wed Feb  5 22:11:48 1997
***************
*** 42,48 ****
  
  COMMANDS    = x_monoid x_monom x_system \
  		x_free x_mat x_relem x_gb \
! 		freemod2 x_factor x_remote gbnod
  
  NAMES       = res respoly hilb frac \
  		polyring freemod matrix relem ring vector z_mod_p Z \
--- 42,48 ----
  
  COMMANDS    = x_monoid x_monom x_system \
  		x_free x_mat x_relem x_gb \
! 		freemod2 x_factor x_remote
  
  NAMES       = res respoly hilb frac \
  		polyring freemod matrix relem ring vector z_mod_p Z \
***************
*** 51,64 ****
  		comb \
  		mem int_bag intarray \
  		monorder monomial varpower monoid remote remotegb \
! 		gb spair gbinhom geobucket random gb2 \
! 		res2 respoly2
  #		termideal gbinhom2
  
  FOR_LATER    =  res2 respoly2 \
  		hilb hilbring
  
! NAMES_H     = type comp ringelem style classes index gb_comp respair2
  
  C_FILES     = mac2
  
--- 51,63 ----
  		comb \
  		mem int_bag intarray \
  		monorder monomial varpower monoid remote remotegb \
! 		gb spair gbinhom geobucket random
  #		termideal gbinhom2
  
  FOR_LATER    =  res2 respoly2 \
  		hilb hilbring
  
! NAMES_H     = type comp ringelem style classes index gb_comp
  
  C_FILES     = mac2
  
***************
*** 75,84 ****
  		$(NAMES_H) $(NAMES) \
  		$(INTERFACE_H) $(INTERFACE) $(CONTAINER))
  
! OTHERS := misc Makefile Makefile.secondary test.m2 res_aux.cc res_aux2.cc \
  	gb.hh gb.cc spair_old.hh tests ZmodN1.hh newZ.cc newZ.hh test.cc \
  	newcomp.hh newcomp.cc termideal.cc termideal.hh gbinhom2.cc gbinhom2.hh \
! 	newspair.hh testx.cc res2old.hh
  
  ALLFILES := $(CCFILES) $(CFILES) $(HHFILES) $(OTHERS) 
  
--- 74,83 ----
  		$(NAMES_H) $(NAMES) \
  		$(INTERFACE_H) $(INTERFACE) $(CONTAINER))
  
! OTHERS := misc Makefile Makefile.secondary test.m2 res_aux.cc \
  	gb.hh gb.cc spair_old.hh tests ZmodN1.hh newZ.cc newZ.hh test.cc \
  	newcomp.hh newcomp.cc termideal.cc termideal.hh gbinhom2.cc gbinhom2.hh \
! 	newspair.hh testx.cc
  
  ALLFILES := $(CCFILES) $(CFILES) $(HHFILES) $(OTHERS) 
  
diff -c ./Ngb.cc /home2/mike/src/M/Macaulay2-0.8.12/e/Ngb.cc
*** ./Ngb.cc	Thu Apr 17 19:12:39 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/Ngb.cc	Thu Jan  9 22:07:59 1997
***************
*** 81,94 ****
  }
  
  NGB_comp::NGB_comp(const Matrix &m, int csyz, int nsyz)
-   : gb_comp(COMP_NGB)
  {
    set_up(m, csyz, nsyz);
  }
  
  NGB_comp::NGB_comp(const Matrix &/*m*/, const Matrix &/*gb*/, 
  		   const Matrix &/*mchange*/)
-   : gb_comp(COMP_NGB)
  {
    // MES
  }
--- 81,92 ----
***************
*** 96,109 ****
  NGB_comp::NGB_comp(const Matrix &/*m*/, const Matrix &/*gb*/, 
  		   const Matrix &/*mchange*/, 
  		   const Matrix &/*syz*/)
-   : gb_comp(COMP_NGB)
  {
    // MES
  }
  
  NGB_comp::NGB_comp(const Matrix &/*m*/, int /*collect_syz*/, int /*n_syz*/, 
  		 const ring_elem /*hf*/)
-   : gb_comp(COMP_NGB)
  {
    // MES
  }
--- 94,105 ----
Only in .: TAGS
Only in /home2/mike/src/M/Macaulay2-0.8.12/e: allfiles
diff -c ./array.cc /home2/mike/src/M/Macaulay2-0.8.12/e/array.cc
*** ./array.cc	Thu Apr 17 19:12:39 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/array.cc	Sun Jan  5 21:15:15 1997
***************
*** 62,71 ****
  #include "gb.hh"
  template class ARRAY(gb_elem *);
  template class ARRAY(monideal_pair *);
- 
- #include "respoly2.hh"
- #include "res2.hh"
- template class ARRAY(res2_pair *);
- template class ARRAY(res2_level *);
- template class ARRAY(res2term *);
- 
--- 62,64 ----
diff -c ./classes.hh /home2/mike/src/M/Macaulay2-0.8.12/e/classes.hh
*** ./classes.hh	Thu Apr 17 19:12:39 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/classes.hh	Thu Jul 25 10:29:04 1996
***************
*** 84,94 ****
    class computation;
      class DetComputation;
      class PFaffianComputation;
- class gb_node;
- class gb2_comp;
- class gbres_comp;
- class res2_comp;
- class gb_emitter;
  
  #endif
  
--- 84,89 ----
diff -c ./cmdinst.hh /home2/mike/src/M/Macaulay2-0.8.12/e/cmdinst.hh
*** ./cmdinst.hh	Thu Apr 17 21:20:10 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/cmdinst.hh	Sun Feb 16 16:45:02 1997
***************
*** 70,76 ****
  install_name(ggisborel,"ggisborel");
  install_name(ggisequal,"ggisequal");
  install_name(ggishomogeneous,"ggishomogeneous");
- install_name(ggissubset,"ggissubset");
  install_name(ggiszero,"ggiszero");
  install_name(ggkbasis,"ggkbasis");
  install_name(ggkbasisIn,"ggkbasisIn");
--- 70,75 ----
***************
*** 135,142 ****
  install_name(ggsend,"ggsend");
  install_name(ggsetshift,"ggsetshift");
  install_name(ggshift,"ggshift");
- install_name(ggsimplify,"ggsimplify");
- install_name(ggskeleton,"ggskeleton");
  install_name(ggsparsevector,"ggsparsevector");
  install_name(ggstack,"ggstack");
  install_name(ggstats,"ggstats");
--- 134,139 ----
diff -c ./cmdnames.hh /home2/mike/src/M/Macaulay2-0.8.12/e/cmdnames.hh
*** ./cmdnames.hh	Thu Apr 17 21:20:10 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/cmdnames.hh	Sun Feb 16 16:45:02 1997
***************
*** 70,165 ****
  const int ggisborel = 69;
  const int ggisequal = 70;
  const int ggishomogeneous = 71;
! const int ggissubset = 72;
! const int ggiszero = 73;
! const int ggkbasis = 74;
! const int ggkbasisIn = 75;
! const int ggkbasisOut = 76;
! const int ggker = 77;
! const int ggkoszul = 78;
! const int gglcm = 79;
! const int gglength = 80;
! const int ggleadcoeff = 81;
! const int ggleadcomp = 82;
! const int ggleadmonom = 83;
! const int ggleadterm = 84;
! const int gglift = 85;
! const int ggmatrix = 86;
! const int ggmem = 87;
! const int ggmod = 88;
! const int ggmodtensor = 89;
! const int ggmonideal = 90;
! const int ggmonoid = 91;
! const int ggMOelim = 92;
! const int ggMOgeneral = 93;
! const int ggMOglex = 94;
! const int ggMOgproduct = 95;
! const int ggMOgrevlex = 96;
! const int ggMOlex = 97;
! const int ggMOproduct = 98;
! const int ggMOrevlex = 99;
! const int ggMOwtfcn = 100;
! const int ggMONOMIAL = 101;
! const int ggmonsyz = 102;
! const int ggmult = 103;
! const int ggnegate = 104;
! const int ggnmonoms = 105;
! const int ggnumerator = 106;
! const int ggpairs = 107;
! const int ggpfaffs = 108;
! const int ggpick = 109;
! const int ggpolyring = 110;
! const int ggpop = 111;
! const int ggpoppem = 112;
! const int ggpower = 113;
! const int ggprimes = 114;
! const int ggpromote = 115;
! const int ggqring = 116;
! const int ggquit = 117;
! const int ggradical = 118;
! const int ggreduce = 119;
! const int ggremaining = 120;
! const int ggringmap = 121;
! const int ggreceive = 122;
! const int ggremove = 123;
! const int ggres = 124;
! const int ggreshape = 125;
! const int ggresmap = 126;
! const int ggresmodule = 127;
! const int ggresNmap = 128;
! const int ggresNmodule = 129;
! const int ggsat = 130;
! const int ggschur = 131;
! const int ggsee = 132;
! const int ggselect = 133;
! const int ggsend = 134;
! const int ggsetshift = 135;
! const int ggshift = 136;
! const int ggsimplify = 137;
! const int ggskeleton = 138;
! const int ggsparsevector = 139;
! const int ggstack = 140;
! const int ggstats = 141;
! const int ggSTRING = 142;
! const int ggsubmatrix = 143;
! const int ggsubmodule = 144;
! const int ggsubtract = 145;
! const int ggsymm = 146;
! const int ggtensor = 147;
! const int ggterm = 148;
! const int ggtest = 149;
! const int ggtonet = 150;
! const int ggtostring = 151;
! const int ggtracing = 152;
! const int ggtranspose = 153;
! const int ggtruncate = 154;
! const int ggisunit = 155;
! const int ggvar = 156;
! const int ggvector = 157;
! const int ggGF = 158;
! const int ggZ = 159;
! const int ggZn = 160;
! const int ggzero = 161;
! const int ggzeromat = 162;
! const int ggzeromonoid = 163;
! const int NCOMMANDS = 164;
--- 70,162 ----
  const int ggisborel = 69;
  const int ggisequal = 70;
  const int ggishomogeneous = 71;
! const int ggiszero = 72;
! const int ggkbasis = 73;
! const int ggkbasisIn = 74;
! const int ggkbasisOut = 75;
! const int ggker = 76;
! const int ggkoszul = 77;
! const int gglcm = 78;
! const int gglength = 79;
! const int ggleadcoeff = 80;
! const int ggleadcomp = 81;
! const int ggleadmonom = 82;
! const int ggleadterm = 83;
! const int gglift = 84;
! const int ggmatrix = 85;
! const int ggmem = 86;
! const int ggmod = 87;
! const int ggmodtensor = 88;
! const int ggmonideal = 89;
! const int ggmonoid = 90;
! const int ggMOelim = 91;
! const int ggMOgeneral = 92;
! const int ggMOglex = 93;
! const int ggMOgproduct = 94;
! const int ggMOgrevlex = 95;
! const int ggMOlex = 96;
! const int ggMOproduct = 97;
! const int ggMOrevlex = 98;
! const int ggMOwtfcn = 99;
! const int ggMONOMIAL = 100;
! const int ggmonsyz = 101;
! const int ggmult = 102;
! const int ggnegate = 103;
! const int ggnmonoms = 104;
! const int ggnumerator = 105;
! const int ggpairs = 106;
! const int ggpfaffs = 107;
! const int ggpick = 108;
! const int ggpolyring = 109;
! const int ggpop = 110;
! const int ggpoppem = 111;
! const int ggpower = 112;
! const int ggprimes = 113;
! const int ggpromote = 114;
! const int ggqring = 115;
! const int ggquit = 116;
! const int ggradical = 117;
! const int ggreduce = 118;
! const int ggremaining = 119;
! const int ggringmap = 120;
! const int ggreceive = 121;
! const int ggremove = 122;
! const int ggres = 123;
! const int ggreshape = 124;
! const int ggresmap = 125;
! const int ggresmodule = 126;
! const int ggresNmap = 127;
! const int ggresNmodule = 128;
! const int ggsat = 129;
! const int ggschur = 130;
! const int ggsee = 131;
! const int ggselect = 132;
! const int ggsend = 133;
! const int ggsetshift = 134;
! const int ggshift = 135;
! const int ggsparsevector = 136;
! const int ggstack = 137;
! const int ggstats = 138;
! const int ggSTRING = 139;
! const int ggsubmatrix = 140;
! const int ggsubmodule = 141;
! const int ggsubtract = 142;
! const int ggsymm = 143;
! const int ggtensor = 144;
! const int ggterm = 145;
! const int ggtest = 146;
! const int ggtonet = 147;
! const int ggtostring = 148;
! const int ggtracing = 149;
! const int ggtranspose = 150;
! const int ggtruncate = 151;
! const int ggisunit = 152;
! const int ggvar = 153;
! const int ggvector = 154;
! const int ggGF = 155;
! const int ggZ = 156;
! const int ggZn = 157;
! const int ggzero = 158;
! const int ggzeromat = 159;
! const int ggzeromonoid = 160;
! const int NCOMMANDS = 161;
diff -c ./cmdnames.m2 /home2/mike/src/M/Macaulay2-0.8.12/e/cmdnames.m2
*** ./cmdnames.m2	Thu Apr 17 21:20:55 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/cmdnames.m2	Sun Feb 16 16:45:36 1997
***************
*** 70,164 ****
  ggisborel = gg 69;
  ggisequal = gg 70;
  ggishomogeneous = gg 71;
! ggissubset = gg 72;
! ggiszero = gg 73;
! ggkbasis = gg 74;
! ggkbasisIn = gg 75;
! ggkbasisOut = gg 76;
! ggker = gg 77;
! ggkoszul = gg 78;
! gglcm = gg 79;
! gglength = gg 80;
! ggleadcoeff = gg 81;
! ggleadcomp = gg 82;
! ggleadmonom = gg 83;
! ggleadterm = gg 84;
! gglift = gg 85;
! ggmatrix = gg 86;
! ggmem = gg 87;
! ggmod = gg 88;
! ggmodtensor = gg 89;
! ggmonideal = gg 90;
! ggmonoid = gg 91;
! ggMOelim = gg 92;
! ggMOgeneral = gg 93;
! ggMOglex = gg 94;
! ggMOgproduct = gg 95;
! ggMOgrevlex = gg 96;
! ggMOlex = gg 97;
! ggMOproduct = gg 98;
! ggMOrevlex = gg 99;
! ggMOwtfcn = gg 100;
! ggMONOMIAL = gg 101;
! ggmonsyz = gg 102;
! ggmult = gg 103;
! ggnegate = gg 104;
! ggnmonoms = gg 105;
! ggnumerator = gg 106;
! ggpairs = gg 107;
! ggpfaffs = gg 108;
! ggpick = gg 109;
! ggpolyring = gg 110;
! ggpop = gg 111;
! ggpoppem = gg 112;
! ggpower = gg 113;
! ggprimes = gg 114;
! ggpromote = gg 115;
! ggqring = gg 116;
! ggquit = gg 117;
! ggradical = gg 118;
! ggreduce = gg 119;
! ggremaining = gg 120;
! ggringmap = gg 121;
! ggreceive = gg 122;
! ggremove = gg 123;
! ggres = gg 124;
! ggreshape = gg 125;
! ggresmap = gg 126;
! ggresmodule = gg 127;
! ggresNmap = gg 128;
! ggresNmodule = gg 129;
! ggsat = gg 130;
! ggschur = gg 131;
! ggsee = gg 132;
! ggselect = gg 133;
! ggsend = gg 134;
! ggsetshift = gg 135;
! ggshift = gg 136;
! ggsimplify = gg 137;
! ggskeleton = gg 138;
! ggsparsevector = gg 139;
! ggstack = gg 140;
! ggstats = gg 141;
! ggSTRING = gg 142;
! ggsubmatrix = gg 143;
! ggsubmodule = gg 144;
! ggsubtract = gg 145;
! ggsymm = gg 146;
! ggtensor = gg 147;
! ggterm = gg 148;
! ggtest = gg 149;
! ggtonet = gg 150;
! ggtostring = gg 151;
! ggtracing = gg 152;
! ggtranspose = gg 153;
! ggtruncate = gg 154;
! ggisunit = gg 155;
! ggvar = gg 156;
! ggvector = gg 157;
! ggGF = gg 158;
! ggZ = gg 159;
! ggZn = gg 160;
! ggzero = gg 161;
! ggzeromat = gg 162;
! ggzeromonoid = gg 163;
--- 70,161 ----
  ggisborel = gg 69;
  ggisequal = gg 70;
  ggishomogeneous = gg 71;
! ggiszero = gg 72;
! ggkbasis = gg 73;
! ggkbasisIn = gg 74;
! ggkbasisOut = gg 75;
! ggker = gg 76;
! ggkoszul = gg 77;
! gglcm = gg 78;
! gglength = gg 79;
! ggleadcoeff = gg 80;
! ggleadcomp = gg 81;
! ggleadmonom = gg 82;
! ggleadterm = gg 83;
! gglift = gg 84;
! ggmatrix = gg 85;
! ggmem = gg 86;
! ggmod = gg 87;
! ggmodtensor = gg 88;
! ggmonideal = gg 89;
! ggmonoid = gg 90;
! ggMOelim = gg 91;
! ggMOgeneral = gg 92;
! ggMOglex = gg 93;
! ggMOgproduct = gg 94;
! ggMOgrevlex = gg 95;
! ggMOlex = gg 96;
! ggMOproduct = gg 97;
! ggMOrevlex = gg 98;
! ggMOwtfcn = gg 99;
! ggMONOMIAL = gg 100;
! ggmonsyz = gg 101;
! ggmult = gg 102;
! ggnegate = gg 103;
! ggnmonoms = gg 104;
! ggnumerator = gg 105;
! ggpairs = gg 106;
! ggpfaffs = gg 107;
! ggpick = gg 108;
! ggpolyring = gg 109;
! ggpop = gg 110;
! ggpoppem = gg 111;
! ggpower = gg 112;
! ggprimes = gg 113;
! ggpromote = gg 114;
! ggqring = gg 115;
! ggquit = gg 116;
! ggradical = gg 117;
! ggreduce = gg 118;
! ggremaining = gg 119;
! ggringmap = gg 120;
! ggreceive = gg 121;
! ggremove = gg 122;
! ggres = gg 123;
! ggreshape = gg 124;
! ggresmap = gg 125;
! ggresmodule = gg 126;
! ggresNmap = gg 127;
! ggresNmodule = gg 128;
! ggsat = gg 129;
! ggschur = gg 130;
! ggsee = gg 131;
! ggselect = gg 132;
! ggsend = gg 133;
! ggsetshift = gg 134;
! ggshift = gg 135;
! ggsparsevector = gg 136;
! ggstack = gg 137;
! ggstats = gg 138;
! ggSTRING = gg 139;
! ggsubmatrix = gg 140;
! ggsubmodule = gg 141;
! ggsubtract = gg 142;
! ggsymm = gg 143;
! ggtensor = gg 144;
! ggterm = gg 145;
! ggtest = gg 146;
! ggtonet = gg 147;
! ggtostring = gg 148;
! ggtracing = gg 149;
! ggtranspose = gg 150;
! ggtruncate = gg 151;
! ggisunit = gg 152;
! ggvar = gg 153;
! ggvector = gg 154;
! ggGF = gg 155;
! ggZ = gg 156;
! ggZn = gg 157;
! ggzero = gg 158;
! ggzeromat = gg 159;
! ggzeromonoid = gg 160;
Only in .: diffs-12-20.log
diff -c ./freemod.cc /home2/mike/src/M/Macaulay2-0.8.12/e/freemod.cc
*** ./freemod.cc	Fri Apr 18 15:17:44 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/freemod.cc	Sat Nov  2 23:29:42 1996
***************
*** 62,73 ****
    if (M == NULL)
      varpower::one(vp);
    else
!     {
!       int *m = M->make_one();
!       M->divide(v->monom, base_monom(v->comp), m);
!       M->to_varpower(m, vp);
!       M->remove(m);
!     }
  }
  
  vec FreeModule::term(int e, ring_elem a, const int *m) const
--- 62,68 ----
    if (M == NULL)
      varpower::one(vp);
    else
!     M->to_varpower(v->monom, vp);
  }
  
  vec FreeModule::term(int e, ring_elem a, const int *m) const
***************
*** 416,452 ****
  }
  
  //////////////////////////////////////////////
- //  Divisibility checks               ////////
- //                                    ////////
- //////////////////////////////////////////////
- 
- int FreeModule::is_scalar_multiple(vec f, vec g) const
-   // is df = cg, some scalars c,d?
- {
-   if (f == NULL) return 1;
-   if (g == NULL) return 1;
-   ring_elem c = f->coeff;
-   ring_elem d = g->coeff;
-   vec p,q;
-   for (p=f, q=g; p != NULL && q != NULL; p=p->next, q=q->next)
-     {
-       if (p->comp != q->comp) return 0;
-       if (M->compare(p->monom, q->monom) != 0) return 0;
-     }
-   for (p=f, q=g; p != NULL && q != NULL; p=p->next, q=q->next)
-     {
-       ring_elem c1 = K->mult(c, q->coeff);
-       ring_elem d1 = K->mult(d, p->coeff);
-       int isequal = K->is_equal(c1, d1);
-       K->remove(c1);
-       K->remove(d1);
-       if (!isequal) return 0;
-     }
-   if (q == NULL && p == NULL) return 1;
-   return 0;
- }
- 
- //////////////////////////////////////////////
  //  Multiplication: may be overridden ////////
  //  by inheritance                    ////////
  //////////////////////////////////////////////
--- 411,416 ----
***************
*** 976,982 ****
    // for each non-zero term f e[component] of the vector v
    //    result += f M[v]
    vec result = NULL, f;
!   switch (F->ty)
      {
      case FREE:
        for ( ; v != NULL; v = v->next)
--- 940,946 ----
    // for each non-zero term f e[component] of the vector v
    //    result += f M[v]
    vec result = NULL, f;
!   switch (ty)
      {
      case FREE:
        for ( ; v != NULL; v = v->next)
***************
*** 1124,1130 ****
  int FreeModule::in_subring(int n, const vec v) const
  {
    if (v == NULL) return 1;
-   // MES BUG!!
    return M->in_subring(n, v->monom);
  }
  
--- 1088,1093 ----
***************
*** 1489,1497 ****
        if (M != NULL)
  	{
  	  vp.shrink(0);
- 	  M->divide(t->monom, base_monom(t->comp), t->monom);
  	  M->to_varpower(t->monom, vp);
- 	  M->mult(t->monom, base_monom(t->comp), t->monom);
  	  r = map.eval_term(K, t->coeff, vp.raw());
  	}
        else
--- 1452,1458 ----
diff -c ./freemod.hh /home2/mike/src/M/Macaulay2-0.8.12/e/freemod.hh
*** ./freemod.hh	Thu Apr 17 19:12:40 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/freemod.hh	Tue Sep 10 10:21:52 1996
***************
*** 20,26 ****
    friend class NGB_comp;
    friend class GB_comp;
    friend class GBinhom_comp;
-   friend class gb2_comp;
  protected:
  
    // free module part
--- 20,25 ----
***************
*** 140,148 ****
    vec term(int r, ring_elem a, const int *m) const;
  
    int compare(const Nvecterm *f, const Nvecterm *g) const;
- 
-   // Some divisibility routines
-   int is_scalar_multiple(vec f, vec g) const;// is cf = dg, some scalars c,d? (not both zero).
  
  //////////////////////////////////////////////
  //  Groebner basis support routines //////////
--- 139,144 ----
diff -c ./gauss.cc /home2/mike/src/M/Macaulay2-0.8.12/e/gauss.cc
*** ./gauss.cc	Thu Apr 17 19:12:40 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/gauss.cc	Thu Jan  9 21:45:25 1997
***************
*** 56,63 ****
  }
  
  GaussElimComputation::GaussElimComputation(const Matrix &m, int collsyz, int nsyz)
!   : gb_comp(COMP_GAUSS),
!   row(m.n_rows()-1),
    gens(m),
    n_gb(0),
    n_pairs(0),
--- 56,62 ----
  }
  
  GaussElimComputation::GaussElimComputation(const Matrix &m, int collsyz, int nsyz)
! : row(m.n_rows()-1),
    gens(m),
    n_gb(0),
    n_pairs(0),
***************
*** 304,345 ****
  
    lift = Vector(syz.rows(), fsyz);
    return Vector(gens.rows(), f);
- }
- int GaussElimComputation::contains(const Matrix &m)
-   // Return -1 if every column of 'm' reduces to zero.
-   // Otherwise return the index of the first column that
-   // does not reduce to zero.
- {
-   // Reduce each column of m one by one.
-   for (int i=0; i<m.n_cols(); i++)
-     {
-       vec f = gens.rows()->translate(m.rows(),m[i]);
-       vec fsyz = NULL;
-       reduce(f, fsyz);
-       syz.rows()->remove(fsyz);
-       if (f != NULL)
- 	{
- 	  gens.rows()->remove(f);
- 	  return i;
- 	}
-     }
-   return -1;
- }
- int GaussElimComputation::is_equal(const gb_comp *q)
- {
-   if (kind() != q->kind()) return 0;
-   GaussElimComputation *qq = (GaussElimComputation *) q;
-   if (gens.rows() != qq->gens.rows()) return 0;
- 
-   for (int i=0; i<gens.n_rows(); i++)
-     {
-       if (gb_list[i] == NULL)
- 	{
- 	  if (qq->gb_list[i] != NULL) return 0;
- 	  continue;
- 	}
-       if (!gens.rows()->is_equal(gb_list[i]->f, qq->gb_list[i]->f))
- 	return 0;
-     }
-   return 1;
  }
--- 303,306 ----
diff -c ./gauss.hh /home2/mike/src/M/Macaulay2-0.8.12/e/gauss.hh
*** ./gauss.hh	Thu Apr 17 19:12:40 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/gauss.hh	Thu Jan  9 21:45:25 1997
***************
*** 64,72 ****
    Matrix reduce(const Matrix &m, Matrix &lift);
    Vector reduce(const Vector &v, Vector &lift);
  
-   virtual int contains(const Matrix &m);
-   virtual int is_equal(const gb_comp *q);
- 
    // infrastructure
    friend void i_stashes();
    static stash *mystash;
--- 64,69 ----
diff -c ./gb.cc /home2/mike/src/M/Macaulay2-0.8.12/e/gb.cc
*** ./gb.cc	Thu Apr 17 19:12:40 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/gb.cc	Sun Jan  5 21:15:16 1997
***************
*** 10,15 ****
--- 10,16 ----
  
  extern ring_elem hilb(const Matrix &M, const Ring *RR);
  
+ stash *monideal_pair::mystash;
  stash *GB_comp::mystash;
  
  void GB_comp::set_up0(const Matrix &m, int csyz, int nsyz)
***************
*** 107,127 ****
  }
  
  GB_comp::GB_comp(const Matrix &m, int csyz, int nsyz, int strat)
-   : gb_comp(COMP_GB)
  {
    set_up(m, csyz, nsyz, strat);
  }
  
  GB_comp::GB_comp(const Matrix &m, const Matrix &gb, const Matrix &mchange, 
  		 const Matrix &syz)
-   : gb_comp(COMP_GB)
  {
    force(m, gb, mchange, syz);
  }
  
  GB_comp::GB_comp(const Matrix &m, int csyz, int nsyz, 
  		 RingElement hf, int strat)
-   : gb_comp(COMP_GB)
  {
    // MES
    set_up(m, csyz, nsyz, strat);
--- 108,125 ----
***************
*** 1014,1069 ****
        lift[i] = fsyz;
      }
    return red;
- }
- 
- int GB_comp::contains(const Matrix &m)
-   // Return -1 if every column of 'm' reduces to zero.
-   // Otherwise return the index of the first column that
-   // does not reduce to zero.
- {
-   // Reduce each column of m one by one.
-   for (int i=0; i<m.n_cols(); i++)
-     {
-       vec f = F->translate(m.rows(),m[i]);
-       vec fsyz = NULL;
-       gb_reduce(f, fsyz);
-       Fsyz->remove(fsyz);
-       if (f != NULL)
- 	{
- 	  F->remove(f);
- 	  return i;
- 	}
-     }
-   return -1;
- }
- int GB_comp::is_equal(const gb_comp *q)
- {
-   if (kind() != q->kind()) return 0;
-   GB_comp *qq = (GB_comp *) q;
-   if (F->rank() != qq->F->rank()) return 0;
- 
-   // Loop through every GB element: in each monideal[i]->mi_search
-   for (int i=0; i<F->rank(); i++)
-     {
-       Index<MonomialIdeal> j1 = monideals[i]->mi_search.first();
-       Index<MonomialIdeal> j2 = qq->monideals[i]->mi_search.first();
-       for (;;)
- 	{
- 	  if (!j1.valid())
- 	    {
- 	      if (!j2.valid()) return 0;
- 	    }
- 	  else if (!j2.valid())
- 	    return 0;
- 	  else {
- 	    vec f1 = (vec) (monideals[i]->mi_search)[j1]->basis_ptr();
- 	    vec f2 = (vec) (qq->monideals[i]->mi_search)[j2]->basis_ptr();
- 	    if (!F->is_equal(f1,f2))
- 	      return 0;
- 	  }
- 	}
-     }
-   return 1;
  }
  
  Vector GB_comp::reduce(const Vector &v, Vector &lift)
--- 1012,1017 ----
diff -c ./gb.hh /home2/mike/src/M/Macaulay2-0.8.12/e/gb.hh
*** ./gb.hh	Thu Apr 17 19:12:40 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/gb.hh	Mon Aug  5 17:34:33 1996
***************
*** 11,16 ****
--- 11,29 ----
  
  #include "spair.hh"
  
+ struct monideal_pair
+ {
+   MonomialIdeal mi;
+   MonomialIdeal mi_search;
+   
+   monideal_pair(const Ring *R) : mi(R), mi_search(R) {}
+ 
+   friend void i_stashes();
+   static stash *mystash;
+   void *operator new(size_t) { return mystash->new_elem(); }
+   void operator delete(void *p) { mystash->delete_elem(p); }
+ };
+ 
  class GB_comp : public gb_comp
  {
  private:
***************
*** 124,132 ****
    Matrix reduce(const Matrix &m, Matrix &lift);
    Vector reduce(const Vector &v, Vector &lift);
  
-   virtual int contains(const Matrix &m);
-   virtual int is_equal(const gb_comp *q);
-   
    // obtaining: mingens matrix, GB matrix, change of basis matrix, stats.
    Matrix min_gens_matrix();
    Matrix initial_matrix(int n);
--- 137,142 ----
Only in .: gb2.cc
Only in .: gb2.hh
diff -c ./gb_comp.hh /home2/mike/src/M/Macaulay2-0.8.12/e/gb_comp.hh
*** ./gb_comp.hh	Thu Apr 17 19:12:41 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/gb_comp.hh	Wed Aug  7 11:11:47 1996
***************
*** 9,25 ****
  extern char system_interrupted;
  extern int comp_printlevel;
  
! // The various kinds of GB computations
! const int COMP_NGB = 10;
! const int COMP_GB = 1;
! const int COMP_GBINHOM = 2;
! const int COMP_HERMITE = 3;
! const int COMP_GAUSS = 4;
! 
! // Possible strategy flags
! const int USE_HILB = 1;
! const int USE_GEOBUCKET = 2;
! const int USE_SORT = 4;
  
  // These are the possible states of a GB computation
  const int GB_COMP_NEWDEGREE        = 1; 
--- 9,16 ----
  extern char system_interrupted;
  extern int comp_printlevel;
  
! const int USE_GEOBUCKET = 8;
! const int USE_SORT = 16;		// Strategy flags
  
  // These are the possible states of a GB computation
  const int GB_COMP_NEWDEGREE        = 1; 
***************
*** 67,80 ****
  
  class gb_comp : public type
  {
- protected:
-   int _kind;  // GB_comp:1, GBinhom_comp:2
  public:
-   gb_comp(int kind) : _kind(kind) {}
    virtual ~gb_comp() {}
  
-   int kind() const { return _kind; }
- 
    virtual int calc(const int *deg, const intarray &stop_conditions) = 0;
    
    virtual void stats() const = 0;
--- 58,66 ----
***************
*** 86,94 ****
  
    virtual Matrix reduce(const Matrix &m, Matrix &result_lift) = 0;
    virtual Vector reduce(const Vector &v, Vector &result_lift) = 0;
- 
-   virtual int contains(const Matrix &m) = 0;
-   virtual int is_equal(const gb_comp *q) = 0;
  
    // Infrastructure
    object_types type_of        () const { return TY_GB_COMP; }
--- 72,77 ----
diff -c ./gbinhom.cc /home2/mike/src/M/Macaulay2-0.8.12/e/gbinhom.cc
*** ./gbinhom.cc	Thu Apr 17 19:12:41 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/gbinhom.cc	Sun Jan  5 21:15:16 1997
***************
*** 101,114 ****
  }
  
  GBinhom_comp::GBinhom_comp(const Matrix &m, int csyz, int nsyz, int strat)
-   : gb_comp(COMP_GBINHOM)
  {
    set_up(m, csyz, nsyz, strat);
  }
  
  GBinhom_comp::GBinhom_comp(const Matrix &m, const Matrix &gb, const Matrix &mchange, 
  		 const Matrix &syz)
-   : gb_comp(COMP_GBINHOM)
  {
    force(m, gb, mchange, syz);
  }
--- 101,112 ----
***************
*** 843,874 ****
  
    lift = Vector(Fsyz, fsyz);
    return Vector(F, f);
- }
- 
- int GBinhom_comp::contains(const Matrix &m)
-   // Return -1 if every column of 'm' reduces to zero.
-   // Otherwise return the index of the first column that
-   // does not reduce to zero.
- {
-   // Reduce each column of m one by one.
-   for (int i=0; i<m.n_cols(); i++)
-     {
-       vec f = F->translate(m.rows(),m[i]);
-       vec fsyz = NULL;
-       gb_reduce(f, fsyz);
-       Fsyz->remove(fsyz);
-       if (f != NULL)
- 	{
- 	  F->remove(f);
- 	  return i;
- 	}
-     }
-   return -1;
- }
- int GBinhom_comp::is_equal(const gb_comp *q)
- {
-   *gError << "== not yet implemented for inhomogeneous GB's";
-   return 0;
  }
  
  //--- Obtaining matrices as output -------
--- 841,846 ----
diff -c ./gbinhom.hh /home2/mike/src/M/Macaulay2-0.8.12/e/gbinhom.hh
*** ./gbinhom.hh	Thu Apr 17 19:12:41 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/gbinhom.hh	Wed Aug  7 11:11:47 1996
***************
*** 98,106 ****
    Matrix reduce(const Matrix &m, Matrix &lift);
    Vector reduce(const Vector &v, Vector &lift);
  
-   virtual int contains(const Matrix &m);
-   virtual int is_equal(const gb_comp *q);
- 
    // obtaining: mingens matrix, GB matrix, change of basis matrix, stats.
    Matrix min_gens_matrix();
    Matrix initial_matrix(int n);
--- 98,103 ----
Only in .: gbnod.cc
diff -c ./hermite.cc /home2/mike/src/M/Macaulay2-0.8.12/e/hermite.cc
*** ./hermite.cc	Thu Apr 17 19:12:41 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/hermite.cc	Wed Jan  8 16:38:20 1997
***************
*** 46,53 ****
  }
  
  HermiteComputation::HermiteComputation(const Matrix &m, int collsyz, int nsyz)
!   : gb_comp(COMP_HERMITE),
!   row(m.n_rows()-1),
    gens(m),
    GB_list(NULL),
    n_gb(0),
--- 46,52 ----
  }
  
  HermiteComputation::HermiteComputation(const Matrix &m, int collsyz, int nsyz)
! : row(m.n_rows()-1),
    gens(m),
    GB_list(NULL),
    n_gb(0),
***************
*** 337,468 ****
    return n_gb;
  }
  
! void HermiteComputation::gb_reduce(vec &f, vec &fsyz) const
  {
!   // Reduce f so that each of its terms are < corresponding initial term
!   // (in absolute value).
!   Nvecterm head;
!   Nvecterm *result = &head;
!   ring_elem coeff;
! #if 0
!   while (f != NULL)
!     {
!       int c = f->comp;
!       
!       hm_elem *p = GB_list;
!       while (p != NULL)
! 	{
! 	  if (p->f->comp == c)
! 	    break;
! 	  if (p->f->comp > c)
! 	    {
! 	      p = NULL;
! 	      break;
! 	    }
! 	  p = p->next;
! 	}
!       if (p != NULL)
! 	{
! 	  // Check whether we should subtract some multiple
! 	  mpz_abs(a, MPZ_VAL(f->coeff));
! 	  int cmp = mpz_cmp(a, MPZ_VAL(p->f->coeff));
! 	  int sgn = mpz_sgn(MPZ_VAL(f->coeff));
! 	  if (sgn > 0 && cmp >= 0)
! 	    {
! 	      // determine the multiple
! 	      // subtract off from f, fsyz
! 
! 	      // Perform the division:
! 	      mpz_...(a, f->coeff, p->f->coeff);
! 	      vec f1 = gens.rows()->mult(a, p->f);
! 	      vec fsyz1 = syz.rows()->mult(a,p->fsyz);
! 	      ges.rows()->subtract_to(f, f1);
! 	      syz.rows()->subtract_to(fsyz, fsyz1);
! 	    }
! 	}
!       // If no divisors, or the divisor is larger than lead coeff of f:
!       if (f->comp == c)
! 	{
! 	  result->next = f;
! 	  f = f->next;
! 	  result = result->next;
! 	}
!     }
! #endif
!   result->next = NULL;
!   f = head.next;
! }
! Matrix HermiteComputation::reduce(const Matrix &m, Matrix &lift)
! {
!   Matrix red(m.rows(), m.cols(), m.degree_shift());
!   lift = Matrix(syz.rows(), m.cols());
!   if (m.n_rows() != gens.rows()->rank()) {
!        *gError << "expected matrices to have same number of rows";
!        return red;
!   }
!   for (int i=0; i<m.n_cols(); i++)
!     {
!       vec f = gens.rows()->copy(m[i]);
!       vec fsyz = NULL;
! 
!       gb_reduce(f, fsyz);
!       syz.rows()->negate_to(fsyz);
!       red[i] = f;
!       lift[i] = fsyz;
!     }
!   return red;
  }
  
! Vector HermiteComputation::reduce(const Vector &v, Vector &lift)
  {
!   if (!v.free_of()->is_equal(gens.rows()))
!     {
!       *gError << "reduce: vector is in incorrect free module";
!       return Vector(gens.rows(), NULL);
!     }
!   vec f = gens.rows()->copy(v.get_value());
!   vec fsyz = NULL;
! 
!   gb_reduce(f, fsyz);
!   syz.rows()->negate_to(fsyz);
! 
!   lift = Vector(syz.rows(), fsyz);
!   return Vector(gens.rows(), f);
! }
! int HermiteComputation::contains(const Matrix &m)
!   // Return -1 if every column of 'm' reduces to zero.
!   // Otherwise return the index of the first column that
!   // does not reduce to zero.
! {
!   // Reduce each column of m one by one.
!   for (int i=0; i<m.n_cols(); i++)
!     {
!       vec f = gens.rows()->translate(m.rows(),m[i]);
!       vec fsyz = NULL;
!       gb_reduce(f, fsyz);
!       syz.rows()->remove(fsyz);
!       if (f != NULL)
! 	{
! 	  gens.rows()->remove(f);
! 	  return i;
! 	}
!     }
!   return -1;
! }
! int HermiteComputation::is_equal(const gb_comp *q1)
! {
!   if (kind() != q1->kind()) return 0;
!   HermiteComputation *qq = (HermiteComputation *) q1;
!   if (gens.rows() != qq->gens.rows()) return 0;
! 
!   hm_elem *q = qq->GB_list;
!   for (hm_elem *p = GB_list; p != NULL; p = p->next)
!     {
!       if (q == NULL) return 0;
!       if (!gens.rows()->is_equal(p->f, q->f))
! 	return 0;
!       q = q->next;
!     }
!   if (q != NULL) return 0;
!   return 1;
  }
--- 336,351 ----
    return n_gb;
  }
  
! Matrix HermiteComputation::reduce(const Matrix &m, Matrix &/*lift*/)
  {
!   // MES
!   *gError << "reduction not yet implemented for modules over Z";
!   return m;
  }
  
! Vector HermiteComputation::reduce(const Vector &v, Vector &/*lift*/)
  {
!   // MES
!   *gError << "reduction not yet implemented for modules over Z";
!   return v;
  }
diff -c ./hermite.hh /home2/mike/src/M/Macaulay2-0.8.12/e/hermite.hh
*** ./hermite.hh	Thu Apr 17 19:12:42 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/hermite.hh	Wed Jul 24 02:40:57 1996
***************
*** 63,74 ****
    Matrix syz_matrix();
    void stats() const;
  
-   void gb_reduce(vec &f, vec &fsyz) const;
    Matrix reduce(const Matrix &m, Matrix &lift);
    Vector reduce(const Vector &v, Vector &lift);
- 
-   virtual int contains(const Matrix &m);
-   virtual int is_equal(const gb_comp *q);
  
    // infrastructure
    friend void i_stashes();
--- 63,70 ----
diff -c ./hilb.cc /home2/mike/src/M/Macaulay2-0.8.12/e/hilb.cc
*** ./hilb.cc	Thu Apr 17 19:12:42 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/hilb.cc	Tue Sep 10 10:21:52 1996
***************
*** 573,618 ****
        d--;
      }
  }
- int hilb_comp::hilbertSeries(const Matrix &M, RingElement &result)
- {
-   const PolynomialRing *P = M.Ring_of()->HilbertRing();
-   hilb_comp *hf = new hilb_comp(P,M);
-   int retval = hf->calc(-1);
-   if (retval != COMP_DONE) return 1;
-   result = hf->value();
-   delete hf;
-   return 0;
- }
- #if 0
- RingElement hilb_comp::hilbertSeries(const FreeModule *F)
- {
-   const Ring *P = F->Ring_of()->HilbertRing();
-   RingElement result(P);
-   for (int i=0; i<F->rank(); i++)
-     result += RingElement(P,...);
-   return result;
- }
- #endif
  
- int hilb_comp::coeff_of(const RingElement &h, int deg)
- {
-   // This is a bit of a kludge of a routine.  The idea is to loop through
-   // all the terms of the polynomial h, expand out the exponent, and to add
-   // up the small integer values of the coefficients of those that have exp[0]=deg.
-   const PolynomialRing *P = h.Ring_of()->cast_to_poly_ring();
- 
-   int *exp = new int[P->n_vars()];
-   int result = 0;
-   for (Nterm *f = h.get_value(); f!=NULL; f=f->next)
-     {
-       P->Nmonoms()->to_expvector(f->monom, exp);
-       if (exp[0] == deg)
- 	{
- 	  int n = P->Ncoeffs()->coerce_to_int(f->coeff);
- 	  result += n;
- 	}
- 	
-     }
-   delete [] exp;
-   return result;
- }
--- 573,576 ----
diff -c ./hilb.hh /home2/mike/src/M/Macaulay2-0.8.12/e/hilb.hh
*** ./hilb.hh	Thu Apr 17 19:12:42 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/hilb.hh	Wed Jul 24 02:48:27 1996
***************
*** 93,106 ****
    RingElement value();
    void stats() const;
  
-   // static routines
-   static int coeff_of(const RingElement &h, int deg);
- 
-   static int hilbertSeries(const Matrix &M, RingElement &result);
-   // A return of 0 means that the result can be used.  A non-zero return
-   // value means that the computation was interrupted, and so control should
-   // return to the user.
- 
    // infrastructure
    friend void i_stashes();
    static stash *mystash;
--- 93,98 ----
diff -c ./interp.cc /home2/mike/src/M/Macaulay2-0.8.12/e/interp.cc
*** ./interp.cc	Thu Apr 17 19:12:42 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/interp.cc	Thu Jan  9 21:46:53 1997
***************
*** 24,31 ****
  extern int i_factor_cmds();
  extern int i_remote_gb_cmds();
  extern int i_res_cmds();
- extern int i_res2_cmds();
- extern int i_gbres_cmds();
  
  void GB_gbforget(int h)
  {
--- 24,29 ----
***************
*** 52,59 ****
    i_Vector_cmds();
    i_Matrix_cmds();
    i_res_cmds();
-   i_res2_cmds();
-   i_gbres_cmds();
    i_factor_cmds();
    i_remote_gb_cmds();
    Random::i_random();
--- 50,55 ----
Common subdirectories: ./keep and /home2/mike/src/M/Macaulay2-0.8.12/e/keep
diff -c ./matrix.cc /home2/mike/src/M/Macaulay2-0.8.12/e/matrix.cc
*** ./matrix.cc	Thu Apr 17 19:15:20 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/matrix.cc	Thu Jan  9 21:46:53 1997
***************
*** 183,190 ****
  	{
  	  vec v = F->translate(rows(), elem(i));
  	  vec w = F->translate(m.rows(), m[i]);
! 	  F->add_to(v,w);
! 	  result[i] = v;
  	}
      }
    return result;
--- 183,189 ----
  	{
  	  vec v = F->translate(rows(), elem(i));
  	  vec w = F->translate(m.rows(), m[i]);
! 	  result[i] = F->add(v, w);
  	}
      }
    return result;
***************
*** 219,226 ****
  	{
  	  vec v = F->translate(rows(), elem(i));
  	  vec w = F->translate(m.rows(), m[i]);
! 	  F->subtract_to(v,w);
! 	  result[i] = v;
  	}
      }
    return result;
--- 218,224 ----
  	{
  	  vec v = F->translate(rows(), elem(i));
  	  vec w = F->translate(m.rows(), m[i]);
! 	  result[i] = F->subtract(v, w);
  	}
      }
    return result;
***************
*** 575,643 ****
    return result;
  }
  
- static int signdivide(int n, const int *a, const int *b, int *exp)
- {
-   int sign = 0;
-   int sum = 0;
-   for (int i=0; i<n; i++)
-     {
-       int e = a[i] - b[i];
-       if (e < 0) return 0;
-       exp[i] = e;
-       sign += sum*e;
-       sum += b[i];
-     }
-   sign %= 2;
-   if (sign == 0) return 1;
-   return -1;
- }
- Matrix Matrix::koszul(const Matrix &r, const Matrix &c)
- {
-   // First check rings: r,c,'this' should be row vectors.
-   const FreeModule *F = r.cols();
-   const Ring *R = F->Ring_of();
-   const monoid *M = R->Nmonoms();
-   
-   // Create result matrix
-   Matrix result(F, c.cols());
- 
-   if (M == NULL) return result;
- 
-   int nvars = F->Ring_of()->n_vars();
-   int nrows = r.n_cols();
-   int ncols = c.n_cols();
-   int *aexp = new int[nvars];
-   int *bexp = new int[nvars];
-   int *result_exp = new int[nvars];
-   for (int i=0; i<ncols; i++)
-     {
-       if (c[i] == NULL) continue;
-       const int *a = c[i]->monom;
-       M->to_expvector(a, aexp);
-       vec v = NULL;
-       for (int j=0; j<nrows; j++)
- 	{
- 	  if (r[j] == NULL) continue;
- 	  const int *b = r[j]->monom;
- 	  M->to_expvector(b, bexp);
- 	  int sign = signdivide(nvars, aexp, bexp, result_exp);
- 	  if (sign != 0)
- 	    {
- 	      ring_elem f = R->from_int(sign);
- 	      M->from_expvector(result_exp, f.poly_val->monom);
- 	      vec p = F->term(j,f);
- 	      p->next = v;
- 	      v = p;
- 	    }
- 	}
-       F->sort(v);
-       result[i] = v;
-     }
-   delete [] aexp;
-   delete [] bexp;
-   delete [] result_exp;
-   return result;
- }
  
  #if 0
  
--- 573,578 ----
***************
*** 848,906 ****
  
    delete [] exp;
    delete [] scratch_exp;
-   return result;
- }
- Matrix Matrix::simplify(int n) const
- {
-   int i,j, keep;
-   Matrix result(rows());
- 
-   switch (n) {
-   case 1:
-     for (i=0; i<n_cols(); i++)
-       {
- 	vec f = elem(i);
- 	if (f == NULL) continue;
- 	result.append(rows()->copy(f));
-       }
-     break;
-     //  case SIMP_SCALAR_MULTIPLES:
-   case 2:
-     for (i=0; i<n_cols(); i++)
-       {
- 	vec f = elem(i);
- 	if (f == NULL) continue;
- 	keep = 1;
- 	for (j=i+1; j<n_cols(); j++)
- 	  {
- 	    vec g = elem(j);
- 	    if (g == NULL) continue;
- 	    if (rows()->is_scalar_multiple(f, g))
- 	      {
- 		keep = 0;
- 		break;
- 	      }
- 	  }
- 	if (keep) result.append(rows()->copy(f));
-       }
-     break;
- #if 0
-   case SIMP_ZEROS:
-     break;
-   case SIMP_MULTIPLES:
-     break;
-   case SIMP_AUTO_REDUCE:
-     break;
-   case SIMP_SQUAREFREE:
-     break;
-   case SIMP_MONOMIAL_DIVISORS:
-     break;
- #endif
-   default:
-     *gError << "bad simplification type";
-     break;
-   }
- 
    return result;
  }
  Matrix Matrix::coeffs(const int *vars, Matrix &result_monoms) const
--- 783,788 ----
diff -c ./matrix.hh /home2/mike/src/M/Macaulay2-0.8.12/e/matrix.hh
*** ./matrix.hh	Thu Apr 17 19:12:50 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/matrix.hh	Tue Oct  1 18:10:51 1996
***************
*** 122,128 ****
    static Matrix zero(const FreeModule *F, const FreeModule *G);
  
    Matrix koszul(int p) const;
-   static Matrix koszul(const Matrix &rows, const Matrix &cols);
  
    Matrix reshape(const FreeModule *G, const FreeModule *H) const;
    static Matrix flip(const FreeModule *G, const FreeModule *H);
--- 122,127 ----
***************
*** 149,157 ****
    // degrees
    int is_homogeneous() const;
    Matrix homogenize(int v, const int *wts) const;
- 
-   // Simplification of column set
-   Matrix simplify(int n) const;
  
    // Matrix selection
    Matrix lead_term(int n=-1) const; // Select those monomials in each column
--- 148,153 ----
Common subdirectories: ./misc and /home2/mike/src/M/Macaulay2-0.8.12/e/misc
diff -c ./monideal.cc /home2/mike/src/M/Macaulay2-0.8.12/e/monideal.cc
*** ./monideal.cc	Thu Apr 17 19:12:51 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/monideal.cc	Tue Jul 30 19:49:04 1996
***************
*** 7,13 ****
  
  stash *MonomialIdeal_rec::mystash;
  stash *Nmi_node::mystash;
- stash *monideal_pair::mystash;
  
  Nmi_node::~Nmi_node()
  {
--- 7,12 ----
***************
*** 147,184 ****
  	} 
  
        p = p->down();	
-     }
- }
- 
- void MonomialIdeal::find_all_divisors(const int *exp, array<Bag *> &b) const
- {
-   b.shrink(0);
-   if (obj->mi == NULL) return;
- 
-   Nmi_node *p = obj->mi;
- 
-   for (;;)
-     {
-       p = p->right;
- 
-       if (p == p->header)
- 	{
- 	  if ((p = p->down()) == NULL) return;
- 	  continue;
- 	}
-       
-       if (p->exp > exp[p->var])
- 	{
- 	  if ((p = p->header->down()) == NULL) return;
- 	  continue;
- 	}
- 
-       if (p->tag == Nmi_node::leaf) 
- 	{
- 	  b.append(p->baggage());
- 	} 
-       else
- 	p = p->down();	
      }
  }
  
--- 146,151 ----
diff -c ./monideal.hh /home2/mike/src/M/Macaulay2-0.8.12/e/monideal.hh
*** ./monideal.hh	Thu Apr 17 19:12:51 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/monideal.hh	Tue Jul 30 19:35:16 1996
***************
*** 145,152 ****
    int search(const int *m, Bag *&b) const;
          // Search.  Return whether a monomial which divides 'm' is
  	// found.  If so, return the baggage.  'm' is a varpower monomial.
-   void find_all_divisors(const int *exp, array<Bag *> &b) const;
-   // Search. Return a list of all elements which divide 'exp'.
    
    Bag *operator[](Index< MonomialIdeal > i) const;
    Index< MonomialIdeal > first() const;
--- 145,150 ----
***************
*** 176,194 ****
    MonomialIdeal operator+(const MonomialIdeal &F) const;
    MonomialIdeal operator-(const MonomialIdeal &F) const;
    MonomialIdeal operator*(const MonomialIdeal &G) const;
- };
- 
- struct monideal_pair
- {
-   MonomialIdeal mi;
-   MonomialIdeal mi_search;
-   
-   monideal_pair(const Ring *R) : mi(R), mi_search(R) {}
- 
-   friend void i_stashes();
-   static stash *mystash;
-   void *operator new(size_t) { return mystash->new_elem(); }
-   void operator delete(void *p) { mystash->delete_elem(p); }
  };
  
  //-----------------------------------------------------------------
--- 174,179 ----
diff -c ./object.cc /home2/mike/src/M/Macaulay2-0.8.12/e/object.cc
*** ./object.cc	Thu Apr 17 19:12:51 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/object.cc	Thu Jan  9 21:46:53 1997
***************
*** 17,26 ****
  #include "respoly.hh"
  #include "gb.hh"
  #include "gbinhom.hh"
- #include "gb2.hh"
- #include "respoly2.hh"
- #include "res2.hh"
- 
  int refcount_check = 0;
  caster_oil caster;
  
--- 17,22 ----
***************
*** 88,98 ****
    gb_elem::mystash         = new stash("gbelem", sizeof(gb_elem));
    GB_comp::mystash         = new stash("GB", sizeof(GB_comp));
    GBinhom_comp::mystash    = new stash("GBinhom", sizeof(GBinhom_comp));
- 
-   gbres_comp::mystash       = new stash("gbres_comp",sizeof(gbres_comp));
- 
-   res2_comp::mystash       = new stash("res2_comp",sizeof(res2_comp));
-   res2_pair::mystash        = new stash("respair2", sizeof(res2_pair));
  }
  
  
--- 84,89 ----
diff -c ./object.hh /home2/mike/src/M/Macaulay2-0.8.12/e/object.hh
*** ./object.hh	Thu Apr 17 19:12:51 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/object.hh	Thu Jan  9 21:46:53 1997
***************
*** 29,37 ****
      TY_RING_MAP, TY_MONIDEAL, TY_GB_COMP,
      TY_MON_ORDER,
      TY_MONOID, TY_MONOMIAL,
!     TY_COMP, TY_REMOTE_GB_COMP, TY_RES_COMP, TY_HILB_COMP,
!     TY_RES2_COMP,
!     TY_GBRES_COMP
  };
  const object_types TY_INT = TY_RING_ELEM;
  
--- 29,35 ----
      TY_RING_MAP, TY_MONIDEAL, TY_GB_COMP,
      TY_MON_ORDER,
      TY_MONOID, TY_MONOMIAL,
!     TY_COMP, TY_REMOTE_GB_COMP, TY_RES_COMP, TY_HILB_COMP
  };
  const object_types TY_INT = TY_RING_ELEM;
  
***************
*** 69,76 ****
    virtual gb_comp     * cast_to_gb_comp()     { return 0; }
    virtual hilb_comp   * cast_to_hilb_comp()   { return 0; }
    virtual res_comp    * cast_to_res_comp()    { return 0; }
-   virtual res2_comp   * cast_to_res2_comp()    { return 0; }
-   virtual gbres_comp   * cast_to_gbres_comp()    { return 0; }
    virtual Ring       * cast_to_Ring()       { return 0; }
    virtual FreeModule * cast_to_FreeModule() { return 0; }
    virtual remote_gb_comp * cast_to_remote_gb_comp() { return 0; }
--- 67,72 ----
***************
*** 81,88 ****
    virtual const gb_comp     * cast_to_gb_comp()     const { return 0; }
    virtual const hilb_comp   * cast_to_hilb_comp()   const { return 0; }
    virtual const res_comp    * cast_to_res_comp()    const { return 0; }
-   virtual const res2_comp   * cast_to_res2_comp()   const { return 0; }
-   virtual const gbres_comp   * cast_to_gbres_comp()   const { return 0; }
    virtual const Ring       * cast_to_Ring()       const { return 0; }
    virtual const FreeModule * cast_to_FreeModule() const { return 0; }
    virtual const remote_gb_comp * cast_to_remote_gb_comp() const { return 0; }
--- 77,82 ----
diff -c ./polyring.hh /home2/mike/src/M/Macaulay2-0.8.12/e/polyring.hh
*** ./polyring.hh	Thu Apr 17 19:12:51 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/polyring.hh	Thu Jan  9 21:46:54 1997
***************
*** 15,23 ****
    friend class NGB_comp;
    friend class GB_comp;
    friend class res_comp;
-   friend class res2_comp;
    friend class GBinhom_comp;
-   friend class gb2_comp;
  protected:
    stash *pstash;
  
--- 15,21 ----
***************
*** 50,58 ****
    int        get_quotient_elem_length() const { return quotient_ideal.length(); }
  
  
!   virtual int is_field() const     { return (nvars == 0 && K->is_field())
!                                        || (nvars == 1 && quotient_ideal.length() == 1 
! 					   && K->is_field());}
    virtual int is_pid() const       { return (nvars == 1 && K->is_field())
  				       || (nvars == 0 && K->is_pid()); }
    virtual int has_gcd() const      { return (nvars == 1 && K->is_field())
--- 48,54 ----
    int        get_quotient_elem_length() const { return quotient_ideal.length(); }
  
  
!   virtual int is_field() const     { return nvars == 0 && K->is_field(); }
    virtual int is_pid() const       { return (nvars == 1 && K->is_field())
  				       || (nvars == 0 && K->is_pid()); }
    virtual int has_gcd() const      { return (nvars == 1 && K->is_field())
diff -c ./relem.cc /home2/mike/src/M/Macaulay2-0.8.12/e/relem.cc
*** ./relem.cc	Thu Apr 17 19:12:51 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/relem.cc	Thu Jan  9 21:46:54 1997
***************
*** 169,175 ****
      {
        *gError << "gcd requires both elements to have the same "
  	<< "base ring";
!       return *this;
      }
    else 
      {
--- 169,175 ----
      {
        *gError << "gcd requires both elements to have the same "
  	<< "base ring";
!       return NULL;
      }
    else 
      {
diff -c ./res.cc /home2/mike/src/M/Macaulay2-0.8.12/e/res.cc
*** ./res.cc	Thu Apr 17 19:12:51 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/res.cc	Sat Nov 30 13:34:42 1996
***************
*** 30,37 ****
    bump_up(K);
    generator_matrix = mat;
  
-   LengthLimit++;  // This is to deal with the fact that the last step does not
-                   // deal with minimality.
    for (i=0; i<=LengthLimit; i++)
      resn.append(new res_level);
  
--- 30,35 ----
***************
*** 296,381 ****
      }
  }
  
- 
  //////////////////////////////////////////////
  //  Sorting //////////////////////////////////
  //////////////////////////////////////////////
  
- static int compare_type = 0;
- static int EXP1[1000], EXP2[1000];
  int res_comp::compare_res_pairs(res_pair *f, res_pair *g) const
  {
-   int cmp, df, dg;
  //  if (f->compare_num < g->compare_num) return 1;
  //  if (f->compare_num > g->compare_num) return -1;
    // MES: what to do if we obtain equality? Here is one way:
!   switch (compare_type) {
!   case 1:
!     // Compare using descending lexicographic order
!     // on the usual set of variables
!     M->to_expvector(f->base_monom, EXP1);
!     M->to_expvector(g->base_monom, EXP2);
!     for (int i=0; i<M->n_vars(); i++)
!       {
! 	if (EXP1[i] < EXP2[i]) return -1;
! 	if (EXP1[i] > EXP2[i]) return 1;
!       }
!     return 0;
!   case 2:
!     // Compare using ascending lexicographic order
!     // on the usual set of variables
!     M->to_expvector(f->base_monom, EXP1);
!     M->to_expvector(g->base_monom, EXP2);
!     for (int i=0; i<M->n_vars(); i++)
!       {
! 	if (EXP1[i] < EXP2[i]) return 1;
! 	if (EXP1[i] > EXP2[i]) return -1;
!       }
!     return 0;
!   case 3:
!     // Compare using descending lexicographic order
!     // on the reversed set of variables
!     M->to_expvector(f->base_monom, EXP1);
!     M->to_expvector(g->base_monom, EXP2);
!     for (int i=M->n_vars()-1; i>=0; i--)
!       {
! 	if (EXP1[i] < EXP2[i]) return -1;
! 	if (EXP1[i] > EXP2[i]) return 1;
!       }
!     return 0;
!   case 4:
!     // Compare using ascending lexicographic order
!     // on the reversed set of variables
!     M->to_expvector(f->base_monom, EXP1);
!     M->to_expvector(g->base_monom, EXP2);
!     for (int i=M->n_vars()-1; i>=0; i--)
!       {
! 	if (EXP1[i] < EXP2[i]) return 1;
! 	if (EXP1[i] > EXP2[i]) return -1;
!       }
!     return 0;
!   case 5:
!     // The original method, but with degree added, since 
!     // the new skeleton code doesn't just sort elements of
!     // the same degree.
!     df = degree(f);
!     dg = degree(g);
!     if (df > dg) return -1;
!     if (df < dg) return 1;
!     cmp = M->compare(f->base_monom, g->base_monom);
!     if (cmp != 0) return cmp;
!     cmp = f->first->compare_num - g->first->compare_num;
!     if (cmp < 0) return 1;
!     if (cmp > 0) return -1;
!     return 0;
!   default:
!     cmp = M->compare(f->base_monom, g->base_monom);
!     if (cmp != 0) return cmp;
!     cmp = f->first->compare_num - g->first->compare_num;
!     if (cmp < 0) return 1;
!     if (cmp > 0) return -1;
!     return 0;
!   }
    return 0;
  }
  
--- 294,313 ----
      }
  }
  
  //////////////////////////////////////////////
  //  Sorting //////////////////////////////////
  //////////////////////////////////////////////
  
  int res_comp::compare_res_pairs(res_pair *f, res_pair *g) const
  {
  //  if (f->compare_num < g->compare_num) return 1;
  //  if (f->compare_num > g->compare_num) return -1;
    // MES: what to do if we obtain equality? Here is one way:
!   int cmp = M->compare(f->base_monom, g->base_monom);
!   if (cmp != 0) return cmp;
!   cmp = f->first->compare_num - g->first->compare_num;
!   if (cmp < 0) return 1;
!   if (cmp > 0) return -1;
    return 0;
  }
  
***************
*** 388,394 ****
    while (1)
      switch (compare_res_pairs(f, g))
        {
-       case 0:
        case -1:
  	result->next = g;
  	result = result->next;
--- 320,325 ----
***************
*** 409,416 ****
  	    return head.next;
  	  }
  	break;
! 	//      case 0:
! 	//	assert(0);
        }
  }
  
--- 340,347 ----
  	    return head.next;
  	  }
  	break;
!       case 0:
! 	assert(0);
        }
  }
  
***************
*** 1027,1276 ****
        // MES: need to decrement nleft for 'q'.
      }
  }
- #if 0
- void res_comp::skeleton()
-   // Compute the skeleton of the resolution
-   // Currently: this is just used for debugging
- {
-   int level, deg;
- 
-   for (level=1; level < resn.length(); level++)
-     {
-       n_level = level+1;
-       for (deg=0; deg < resn[level]->bin.length(); deg++)
- 	{
- 	  deg += lodegree;
- 	  res_degree *p = get_degree_set(level, deg);
- 	  if (p == NULL) continue;
- 	  if (level == 1)
- 	    {
- 	      // Get the generators back into the game
- 	      p->first = p->next_gen;
- 	      p->next_gen = NULL;
- 	    }
- 	  pairs(level, deg);
- 	}
-     }
- }
- #endif
  
  #include "res_aux.cc"
- 
- //////////////////////////////////////
- // Skeleton construction: test code //
- //////////////////////////////////////
- 
- void res_comp::skeleton_init(array<res_pair *> &reslevel)
- {
-   int i;
- 
-   // Do level 0
-   res_pair *pp = NULL;
-   for (i=base_components.length()-1; i>=0; i--)
-     {
-       res_pair *p = base_components[i];
-       p->next = pp;
-       pp = p;
-     }
-   reslevel.append(pp);
- 
-   // Do level 1
-   pp = NULL;
-   for (i=0; i<generator_matrix.n_cols(); i++)
-     if (generator_matrix[i] != NULL)
-       {
- 	res_pair *p = new_res_pair(i); // Makes a generator 'pair'
- 	p->next = pp;
- 	pp = p;
-       }
-   reslevel.append(pp);
- }
- 
- void res_comp::skeleton_pairs(res_pair *&result, res_pair *p)
-     // Create and insert all of the pairs which will have lead term 'p'.
-     // This also places 'p' into the appropriate monomial ideal
- {
-   Index<MonomialIdeal> j;
-   queue<Bag *> elems;
-   intarray vp;			// This is 'p'.
-   intarray thisvp;
- 
-   if (comp_printlevel >= 10)
-     cerr << "Computing pairs with first = " << p->me << endl;
-   M->divide(p->base_monom, p->first->base_monom, PAIRS_mon);
-   M->to_varpower(PAIRS_mon, vp);
- 
-   // First add in syzygies arising from exterior variables
-   // At the moment, there are none of this sort.
- 
-   if (M->is_skew())
-     {
-       intarray vplcm;
-       intarray find_pairs_vp;
- 
-       int *skewvars = new int[M->n_vars()];
-       varpower::to_ntuple(M->n_vars(), vp.raw(), find_pairs_vp);
-       int nskew = M->exp_skew_vars(find_pairs_vp.raw(), skewvars);
-       
-       // Add in syzygies arising from exterior variables
-       for (int v=0; v < nskew; v++)
- 	{
- 	  int w = skewvars[v];
- 
- 	  thisvp.shrink(0);
- 	  varpower::var(w,1,thisvp);
- 	  Bag *b = new Bag(NULL, thisvp);
- 	  elems.insert(b);
- 	}
-       // Remove the local variables
-       delete [] skewvars;
-     }
- 
-   // Second, add in syzygies arising from the base ring, if any
-   // The baggage of each of these is NULL
-   if (P->base_ring != NULL)
-     for (j = P->Rideal.first(); j.valid(); j++)
-       {
- 	// Compute (P->quotient_ideal->monom : p->monom)
- 	// and place this into a varpower and Bag, placing
- 	// that into 'elems'
- 	thisvp.shrink(0);
- 	varpower::divide(P->Rideal[j]->monom().raw(), vp.raw(), thisvp);
- 	if (varpower::is_equal(P->Rideal[j]->monom().raw(), thisvp.raw()))
- 	  continue;
- 	Bag *b = new Bag(NULL, thisvp);
- 	elems.insert(b);
-       }
-   
-   // Third, add in syzygies arising from previous elements of this same level
-   // The baggage of each of these is their corresponding res_pair
- 
-   MonomialIdeal &mi_orig = p->first->mi;
-   for (j = mi_orig.first(); j.valid(); j++)
-     {
-       Bag *b = new Bag(mi_orig[j]->basis_ptr());
-       varpower::divide(mi_orig[j]->monom().raw(), vp.raw(), b->monom());
-       elems.insert(b);
-     }
- 
-   // Make this monomial ideal, and then run through each minimal generator
-   // and insert into the proper degree. (Notice that sorting does not
-   // need to be done yet: only once that degree is about to begin.
- 
-   mi_orig.insert_minimal(new Bag(p, vp));
- 
-   queue<Bag *> rejects;
-   Bag *b;
-   MonomialIdeal mi(P, elems, rejects);
-   while (rejects.remove(b))
-     delete b;
- 
-   if (comp_printlevel>= 11) mi.debug_out(1);
- 
-   for (j = mi.first(); j.valid(); j++)
-     {
-       res_pair *second = (res_pair *) mi[j]->basis_ptr();
-       res_pair *q = new_res_pair(SYZ_S_PAIR, p, second);
-       // That set most fields except base_monom:
-       M->from_varpower(mi[j]->monom().raw(), q->base_monom);
-       M->mult(q->base_monom, p->base_monom, q->base_monom);
-       result->next = q;
-       result = q;
-     }
- }
- 
- int res_comp::skeleton_maxdegree(const array<res_pair *> &reslevel)
- {
-   int result = lodegree;
-   for (int level=0; level < reslevel.length(); level++)
-     {
-       for (res_pair *p = reslevel[level]; p != NULL; p = p->next)
- 	{
- 	  int d = degree(p);
- 	  if (d-level > result)
- 	    result = d-level;
- 	}
-     }
-   return result;
- }
- 
- void res_comp::skeleton_stats(const array<res_pair *> &reslevel)
- {
-   int level, i, d;
-   int maxlevel = reslevel.length()-1;
-   int maxdegree = skeleton_maxdegree(reslevel); // max slanted degree
-   int *bettis = new int[(maxlevel+1)*(maxdegree+1)];
-   for (i=(maxlevel+1)*(maxdegree+1)-1; i>=0; i--)
-     bettis[i] = 0;
- 
-   for (level=0; level < reslevel.length(); level++)
-     {
-       for (res_pair *p = reslevel[level]; p != NULL; p = p->next)
- 	{
- 	  int d = degree(p);
- 	  d -= level;
- 	  d -= lodegree;
- 	  bettis[level + (maxlevel+1)*d] += 1;
- 	}
-     }
-   
-   // Now make an intarray so that we may just use betti_display
-   intarray betti;
-   betti.append(lodegree);
-   betti.append(maxdegree);
-   betti.append(maxlevel);
-   for (d=0; d<=maxdegree-lodegree; d++)
-     for (level=0; level<=maxlevel; level++)
-       betti.append(bettis[level + (maxlevel+1)*d]);
- 
-   betti_display(cerr, betti);
-   delete [] bettis;
- 
-   for (level=0; level <= maxlevel; level++)
-     {
-       cerr << "---- level " << level << " ----" << endl;
-       for (res_pair *p = reslevel[level]; p != NULL; p = p->next)
- 	{
- 	  int d = degree(p);
- 	  cerr << setw(4) << d << ' ';
- 	  text_out(p);
- 	}
-     }
- }
- 
- void res_comp::skeleton(int strategy)
-   // Compute the skeleton of the resolution
-   // Currently: this is just used for debugging
- {
-   int level;
-   array<res_pair *> reslevel;
- 
-   // First, set reslevel[0], reslevel[1].
-   skeleton_init(reslevel);
- 
-   // Now loop through each level, until the length limit is hit,
-   // or there are no new pairs
- 
-   for (level=1; level < reslevel.length(); level++)
-     {
-       // Sort the pairs in the current level:
-       res_pair *pp = reslevel[level];
-       if (pp == NULL) break;
- 
-       compare_type = strategy;
-       sort_res_pairs(pp);
-       reslevel[level] = pp;
-       compare_type = 0;
- 
-       // Now compute the pairs at the next level
-       res_pair head, *ptrhead;
-       head.next = NULL;
-       ptrhead = &head;
-       for (res_pair *p = pp; p != NULL; p = p->next)
- 	skeleton_pairs(ptrhead, p);
-       reslevel.append(head.next);
-     }
- 
-   // Now display the skeleton and stats on it
-   skeleton_stats(reslevel);
- }
--- 958,962 ----
diff -c ./res.hh /home2/mike/src/M/Macaulay2-0.8.12/e/res.hh
*** ./res.hh	Thu Apr 17 19:12:52 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/res.hh	Mon Feb 24 02:56:18 1997
***************
*** 12,19 ****
  #include "polyring.hh"
  #include "comp.hh"
  
- #include "respoly.hh"
- 
  class res_pair;
  class res_degree;
  class res_level;
--- 12,17 ----
***************
*** 183,195 ****
  	   int SyzLimitValue,
  	   int SyzLimitLevel,
  	   int SyzLimitDegree);
- 
-   void skeleton_init(array<res_pair *> &reslevel);
-   void skeleton_pairs(res_pair *&result, res_pair *p);
-   int skeleton_maxdegree(const array<res_pair *> &reslevel);
-   void skeleton_stats(const array<res_pair *> &reslevel);
- 
-   void skeleton(int strategy);
  
  //////////////////////////////////////////////
  //  Result matrices of the resolution ////////
--- 181,186 ----
Only in .: res2.cc
Only in .: res2.hh
Only in .: res2old.hh
diff -c ./res_aux.cc /home2/mike/src/M/Macaulay2-0.8.12/e/res_aux.cc
*** ./res_aux.cc	Thu Apr 17 19:12:52 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/res_aux.cc	Fri Jul 26 01:19:30 1996
***************
*** 271,277 ****
  {
    FreeModule *result;
    result = new FreeModule(P);
!   if (i < 0 || i >= resn.length()-1)
      return result;
    int *deg = degree_monoid()->make_one();
    int nminimal = 0;
--- 271,277 ----
  {
    FreeModule *result;
    result = new FreeModule(P);
!   if (i < 0 || i >= resn.length())
      return result;
    int *deg = degree_monoid()->make_one();
    int nminimal = 0;
***************
*** 340,346 ****
  Matrix res_comp::make_minimal(int i) const
  {
    Matrix m(minimal_free_of(i-1), minimal_free_of(i));
!   if (i < 0 || i >= resn.length()-1) return m;
    array<res_pair *> elems;
  
    res_level *lev = resn[i];
--- 340,346 ----
  Matrix res_comp::make_minimal(int i) const
  {
    Matrix m(minimal_free_of(i-1), minimal_free_of(i));
!   if (i < 0 || i >= resn.length()) return m;
    array<res_pair *> elems;
  
    res_level *lev = resn[i];
***************
*** 457,473 ****
    gStack.insert(p->minimal_free_of(on->int_of()));
  }
  
- void cmd_res_skeleton(object &op, object &on)
- {
-   res_comp *p = op->cast_to_res_comp();
-   int strategy = on->int_of();
-   p->skeleton(strategy);
- }
- 
  int i_res_cmds()
  {
    // Resolutions
!   //install(ggres, cmd_res, TY_MATRIX, TY_INT, TY_INT);
    install(ggcalc, cmd_res_calc, TY_RES_COMP, TY_INTARRAY, TY_INTARRAY);
  
    install(ggstats, cmd_res_stats, TY_RES_COMP);
--- 457,466 ----
    gStack.insert(p->minimal_free_of(on->int_of()));
  }
  
  int i_res_cmds()
  {
    // Resolutions
!   install(ggres, cmd_res, TY_MATRIX, TY_INT, TY_INT);
    install(ggcalc, cmd_res_calc, TY_RES_COMP, TY_INTARRAY, TY_INTARRAY);
  
    install(ggstats, cmd_res_stats, TY_RES_COMP);
***************
*** 481,486 ****
    install(ggresmodule, cmd_res_module, TY_RES_COMP, TY_INT);
    install(ggresNmodule, cmd_res_Nmodule, TY_RES_COMP, TY_INT);
  
-   install(ggskeleton, cmd_res_skeleton, TY_RES_COMP, TY_INT);
    return 1;
  }
--- 474,478 ----
Only in .: res_aux2.cc
Only in .: respair2.hh
diff -c ./respoly.cc /home2/mike/src/M/Macaulay2-0.8.12/e/respoly.cc
*** ./respoly.cc	Wed Feb 26 23:52:46 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/respoly.cc	Mon Feb 24 17:52:57 1997
***************
*** 16,21 ****
--- 16,22 ----
  
  res_poly::~res_poly()
  {
+   //  delete pstash;
    bump_down(R);
    bump_down(K);
  }
Only in .: respoly2.cc
Only in .: respoly2.hh
diff -c ./ring.cc /home2/mike/src/M/Macaulay2-0.8.12/e/ring.cc
*** ./ring.cc	Thu Apr 17 19:12:52 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/ring.cc	Mon Feb 24 18:07:08 1997
***************
*** 4,10 ****
  #include "monoid.hh"
  #include "monideal.hh"
  #include "respoly.hh"
- #include "polyring.hh"
  
  Ring::Ring(int P, 
  	     int n, 
--- 4,9 ----
***************
*** 12,25 ****
  	     const Ring *KK,
  	     const monoid *MM,
  	     const monoid *DD)
! : type(), P(P), nvars(n), totalvars(totaln), K(KK), M(MM), D(DD),
! HRing(NULL)
  {
    if (K != NULL) bump_up((Ring *) K);
  
-   if (D->n_vars() > 0)
-     HRing = new PolynomialRing(ZZ, D);
- 
    int msize = M->monomial_size();
    vecstash = new stash("vectors",
  		       sizeof(Nvecterm) +
--- 11,20 ----
  	     const Ring *KK,
  	     const monoid *MM,
  	     const monoid *DD)
! : type(), P(P), nvars(n), totalvars(totaln), K(KK), M(MM), D(DD)
  {
    if (K != NULL) bump_up((Ring *) K);
  
    int msize = M->monomial_size();
    vecstash = new stash("vectors",
  		       sizeof(Nvecterm) +
***************
*** 28,33 ****
--- 23,29 ----
    resstash = new stash("respoly", sizeof(resterm *) + sizeof(res_pair *)
  		     + sizeof(ring_elem)
  		     + sizeof(int) * M->monomial_size());
+ 
  }
  
  Ring::Ring(const Ring &R)
diff -c ./ring.hh /home2/mike/src/M/Macaulay2-0.8.12/e/ring.hh
*** ./ring.hh	Thu Apr 17 19:12:52 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/ring.hh	Mon Feb 24 17:51:58 1997
***************
*** 13,19 ****
  {
    friend class FreeModule;
    friend class res_poly;
-   friend class res2_poly;
  protected:
    int P;
    int nvars;
--- 13,18 ----
***************
*** 21,30 ****
    const Ring *K;		// For a base ring, this will point to self
    const monoid *M;
    const monoid *D;
-   const PolynomialRing *HRing;	// Hilbert function ring, if D has >= 1 variables.
- 				// Otherwise, this will be NULL.
    stash *vecstash;		// Stash used to allocate vectors over this ring.
!   stash *resstash;		// For resolutions
  public:
    Ring(int charac, int nvars, int totalvars, const Ring *K, 
  	const monoid *M, const monoid *D);
--- 20,28 ----
    const Ring *K;		// For a base ring, this will point to self
    const monoid *M;
    const monoid *D;
    stash *vecstash;		// Stash used to allocate vectors over this ring.
!   stash *resstash;
! 
  public:
    Ring(int charac, int nvars, int totalvars, const Ring *K, 
  	const monoid *M, const monoid *D);
***************
*** 38,44 ****
    const Ring *  Ncoeffs()       const { return K; }
    const monoid * Nmonoms()       const { return M; }
    const monoid * degree_monoid() const { return D; }
-   const PolynomialRing *HilbertRing() const { return HRing; }
  
    virtual const Z * cast_to_Z() const         { return 0; }
    virtual       Z * cast_to_Z()               { return 0; }
--- 36,41 ----
***************
*** 141,146 ****
    const char * type_name() const    { return "Ring"; }
  };
  
- #include "Z.hh"
- extern Z *ZZ;
  #endif
--- 138,141 ----
diff -c ./ringmap.cc /home2/mike/src/M/Macaulay2-0.8.12/e/ringmap.cc
*** ./ringmap.cc	Mon Mar 17 18:17:54 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/ringmap.cc	Wed Aug  7 11:11:47 1996
***************
*** 43,49 ****
        int e = varpower::exponent(vp[i]);
        ring_elem thispart = Ring_of()->power(elem(first_var + v), e);
        Ring_of()->mult_to(result, thispart);
-       Ring_of()->remove(thispart);
        if (Ring_of()->is_zero(result)) break;
      }
    return result;
--- 43,48 ----
diff -c ./spair.cc /home2/mike/src/M/Macaulay2-0.8.12/e/spair.cc
*** ./spair.cc	Thu Apr 17 19:12:57 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/spair.cc	Wed Jun 19 16:05:20 1996
***************
*** 5,11 ****
  stash *gb_elem::mystash;
  stash *s_pair::mystash;
  
- int compare_type = 0;
  static int heap_size[NHEAP] = {4, 16, 64, 256, 1024, 50000};
  
  s_pair_heap::s_pair_heap(const monoid *MM)
--- 5,10 ----
***************
*** 27,33 ****
    // have been removed first.  Thus, we don't need to
    // do anything here.
  }
! #if 0
  int s_pair_heap::compare(s_pair *f, s_pair *g) const
  {
    int cmp = f->degree - g->degree;
--- 26,32 ----
    // have been removed first.  Thus, we don't need to
    // do anything here.
  }
! 
  int s_pair_heap::compare(s_pair *f, s_pair *g) const
  {
    int cmp = f->degree - g->degree;
***************
*** 40,88 ****
    cmp = f->first->me - g->first->me;
    if (cmp > 0) return 1;
    if (cmp < 0) return -1;
-   return 0;
- }
- #endif
- int s_pair_heap::compare(s_pair *f, s_pair *g) const
- {
-   int cmp = f->degree - g->degree;
-   if (cmp < 0) return -1;
-   if (cmp > 0) return 1;
-   switch (compare_type) {
-   case 0:
-     cmp = M->compare(f->lcm, g->lcm);
-     if (cmp != 0) return cmp;
-     if (f->first == NULL || g->first == NULL)
-       return 0;
-     cmp = f->first->me - g->first->me;
-     if (cmp > 0) return 1;
-     if (cmp < 0) return -1;
-     break;
-   case 1:
-     if (f->first != NULL && g->first != NULL)
-       {
- 	cmp = f->first->me - g->first->me;
- 	if (cmp < 0) return -1;
- 	if (cmp > 0) return 1;
-       }
-     if (f->second != NULL && g->second != NULL)
-       {
- 	cmp = f->second->me - g->second->me;
- 	if (cmp < 0) return -1;
- 	if (cmp > 0) return 1;
-       }
-     cmp = M->compare(f->lcm, g->lcm);
-     if (cmp != 0) return cmp;
-     if (f->first == NULL || g->first == NULL)
-       return 0;
-     cmp = f->first->me - g->first->me;
-     if (cmp > 0) return 1;
-     if (cmp < 0) return -1;
-     break;
-   case 2:
-     return -1;
-     break;
-   }
    return 0;
  }
  
--- 39,44 ----
diff -c ./test.m2 /home2/mike/src/M/Macaulay2-0.8.12/e/test.m2
*** ./test.m2	Thu Apr 17 19:12:57 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/test.m2	Tue Feb  6 23:55:07 1996
***************
*** 24,42 ****
      m = (vars RS)_(map(2,identity));
      --subst(f, m);
      );
- 
- R = ZZ/101[a..d]
- I = monomialCurve(R,{1,3,4})
- m = matrix entries gens gb I
- gbTrace 3
- C = res(coker m, SortStrategy=>2)
- sendgg(ggPush C.Resolution, ggstats)
- sendgg(ggPush C.Resolution, ggPush 1, ggresNmap); getMatrix R
- sendgg(ggPush C.Resolution, ggPush 2, ggresNmap); getMatrix R
- sendgg(ggPush C.Resolution, ggPush 3, ggresNmap); getMatrix R
- sendgg(ggPush C.Resolution, ggPush 4, ggresNmap); getMatrix R
- 
- sendgg(ggPush C.Resolution, ggPush 1, ggresmap); getMatrix R
- sendgg(ggPush C.Resolution, ggPush 2, ggresmap); getMatrix R
- sendgg(ggPush C.Resolution, ggPush 3, ggresmap); getMatrix R
- sendgg(ggPush C.Resolution, ggPush 4, ggresmap); getMatrix R
--- 24,26 ----
Common subdirectories: ./tests and /home2/mike/src/M/Macaulay2-0.8.12/e/tests
diff -c ./x_factor.cc /home2/mike/src/M/Macaulay2-0.8.12/e/x_factor.cc
*** ./x_factor.cc	Mon Apr  7 14:59:21 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/x_factor.cc	Wed Nov 20 21:17:59 1996
***************
*** 4,10 ****
  
  #include "z_mod_p.hh"
  #include "matrix.hh"
- #include "Z.hh"
  
  ostream &operator<<(ostream &o,const intarray &w) {
       o << hex;
--- 4,9 ----
***************
*** 45,88 ****
       return q;
  }
  
- static int base_set = 0;
- static CanonicalForm base;
- 
- static CanonicalForm convert(mpz_ptr p) {
-      int size = p -> _mp_size;
-      int sign = size < 0 ? -1 : 1;
-      if (size < 0) size = -size;
-      if (!base_set) {
- 	  base_set = 1;
- 	  base = 1;
- 	  for (int i = 0; i < mp_bits_per_limb; i++) base *= 2;
-      }
-      CanonicalForm m = 0;
-      for (int i = 0; i < size; i++) m = base * m + p -> _mp_d[i];
-      return m * sign;
- }
- 
  static CanonicalForm convert(const RingElement &g) {
       const Ring *R = g.Ring_of();
       const Ring *F = R->Ncoeffs();
       const Z_mod *Zn = F->cast_to_Z_mod();
!      const Z *Z0 = F->cast_to_Z();
!      if (Zn == NULL && Z0 == NULL) {
! 	  *gError << "expected coefficient ring of the form ZZ/n or ZZ";
  	  return 0;
       }
       const monoid *M = R->Nmonoms();
       intarray vp;
       setCharacteristic(R->charac());
       CanonicalForm f = 0;
       for (Nterm *t = g.get_value(); t != NULL; t = t->next) {
         vp.shrink(0);
         M->to_varpower(t->monom,vp);
!        CanonicalForm m = (
! 			  Zn != NULL ?
! 			  CanonicalForm(Zn->to_int(t->coeff)) :
! 			  convert(MPZ_VAL(t->coeff))
! 			  );
         for (int l = 1; l < vp[0] ; l++) {
  	 m *= power(
  		    Variable(1 + varpower::var(vp[l])), 
--- 44,66 ----
       return q;
  }
  
  static CanonicalForm convert(const RingElement &g) {
       const Ring *R = g.Ring_of();
       const Ring *F = R->Ncoeffs();
       const Z_mod *Zn = F->cast_to_Z_mod();
!      if (Zn == 0) {
! 	  *gError << "expected coefficient ring of the form Z/n";
  	  return 0;
       }
       const monoid *M = R->Nmonoms();
       intarray vp;
+ 
       setCharacteristic(R->charac());
       CanonicalForm f = 0;
       for (Nterm *t = g.get_value(); t != NULL; t = t->next) {
         vp.shrink(0);
         M->to_varpower(t->monom,vp);
!        CanonicalForm m = Zn->to_int(t->coeff);
         for (int l = 1; l < vp[0] ; l++) {
  	 m *= power(
  		    Variable(1 + varpower::var(vp[l])), 
***************
*** 102,118 ****
       gStack.insert(convert(R,h));
  }
  
- static void extgcd_ring_elem(object &ff, object &gg) {
-      const RingElement &f = ff -> cast_to_RingElement();
-      const RingElement &g = gg -> cast_to_RingElement();
-      const Ring *R = f.Ring_of();
-      CanonicalForm p, q;
-      CanonicalForm h = extgcd(convert(f),convert(g),p,q);
-      gStack.insert(convert(R,p));
-      gStack.insert(convert(R,q));
-      gStack.insert(convert(R,h));
- }
- 
  static void pseudo_remainder(object &ff, object &gg) {
       const RingElement &f = ff -> cast_to_RingElement();
       const RingElement &g = gg -> cast_to_RingElement();
--- 80,85 ----
***************
*** 132,145 ****
       gStack.insert(new object_int(q.length()));
  }
  
! static void ideal_reorder(object &mm) {
       const Matrix &m = mm -> cast_to_Matrix();
       const Ring *R = m.Ring_of();
       const Ring *F = R->Ncoeffs();
       const Z_mod *Zn = F->cast_to_Z_mod();
!      const Z *Z0 = F->cast_to_Z();
!      if (Zn == NULL && Z0 == NULL) {
! 	  *gError << "expected coefficient ring of the form ZZ/n or ZZ";
  	  return;
       }
       CFList I;
--- 99,111 ----
       gStack.insert(new object_int(q.length()));
  }
  
! void ideal_charset(object &mm) {
       const Matrix &m = mm -> cast_to_Matrix();
       const Ring *R = m.Ring_of();
       const Ring *F = R->Ncoeffs();
       const Z_mod *Zn = F->cast_to_Z_mod();
!      if (Zn == 0) {
! 	  *gError << "expected coefficient ring of the form Z/n";
  	  return;
       }
       CFList I;
***************
*** 149,180 ****
  	       I.append(convert(g));
  	  }
       }
-      List<int> t = neworderint(I);
-      intarray u(t.length());
-      ListIterator<int> ii(t);
-      int i=0;
-      for (; ii.hasItem(); ii++, i++) u.append(ii.getItem());
-      gStack.insert(new object_intarray(u));
- }    
- 
- static void ideal_charset(object &mm) {
-      const Matrix &m = mm -> cast_to_Matrix();
-      const Ring *R = m.Ring_of();
-      const Ring *F = R->Ncoeffs();
-      const Z_mod *Zn = F->cast_to_Z_mod();
-      const Z *Z0 = F->cast_to_Z();
-      if (Zn == NULL && Z0 == NULL) {
- 	  *gError << "expected coefficient ring of the form ZZ/n or ZZ";
- 	  return;
-      }
-      CFList I;
-      int i;
-      for (i = 0; i < m.n_rows(); i++) {
- 	  for (int j=0; j < m.n_cols(); j++) {
- 	       RingElement g(R, m.elem(i,j));
- 	       I.append(convert(g));
- 	  }
-      }
       List<CFList> t = IrrCharSeries(I);
       for (ListIterator<List<CanonicalForm> > ii = t; ii.hasItem(); ii++) {
  	  CFList u = ii.getItem();
--- 115,120 ----
***************
*** 184,197 ****
  	  gStack.insert(new object_int(u.length()));
       }
       gStack.insert(new object_int(t.length()));
! }    
  
  void i_factor_cmds() {
       install(ggfactor, factor_ring_elem, TY_RING_ELEM);
       install(ggfactor1, gcd_ring_elem, TY_RING_ELEM, TY_RING_ELEM);
-      // install(ggfactor, extgcd_ring_elem, TY_RING_ELEM, TY_RING_ELEM);
       install(ggfactor2, pseudo_remainder, TY_RING_ELEM, TY_RING_ELEM);
-      install(ggfactor1, ideal_reorder, TY_MATRIX);
       install(ggfactor2, ideal_charset, TY_MATRIX);
  }
  
--- 124,135 ----
  	  gStack.insert(new object_int(u.length()));
       }
       gStack.insert(new object_int(t.length()));
! }     
  
  void i_factor_cmds() {
       install(ggfactor, factor_ring_elem, TY_RING_ELEM);
       install(ggfactor1, gcd_ring_elem, TY_RING_ELEM, TY_RING_ELEM);
       install(ggfactor2, pseudo_remainder, TY_RING_ELEM, TY_RING_ELEM);
       install(ggfactor2, ideal_charset, TY_MATRIX);
  }
  
diff -c ./x_gb.cc /home2/mike/src/M/Macaulay2-0.8.12/e/x_gb.cc
*** ./x_gb.cc	Thu Apr 17 19:12:57 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/x_gb.cc	Thu Jan  9 21:46:55 1997
***************
*** 10,19 ****
  #include "hermite.hh"
  #include "gauss.hh"
  
- #include "gb2.hh"
- #include "res.hh"
- #include "res2.hh"
- 
  extern int comp_printlevel;
  extern Z *ZZ;
  
--- 10,15 ----
***************
*** 47,56 ****
        if (R->is_graded() && m.is_homogeneous())
  	{
  	  if ((strategy & 3) == 1)
! 	    {
! 	      //gStack.insert(new NGB_comp(m, dosyz, nsyz));
! 	      gStack.insert(new GB_comp(m, dosyz, nsyz, strategy));
! 	    }
  	  else if ((strategy & 3) == 2)
  	    gStack.insert(new GBinhom_comp(m, dosyz, nsyz, strategy));
  	  else 
--- 43,49 ----
        if (R->is_graded() && m.is_homogeneous())
  	{
  	  if ((strategy & 3) == 1)
! 	    gStack.insert(new NGB_comp(m, dosyz, nsyz));
  	  else if ((strategy & 3) == 2)
  	    gStack.insert(new GBinhom_comp(m, dosyz, nsyz, strategy));
  	  else 
***************
*** 223,243 ****
    gStack.insert(red);
    gStack.insert(lift);
  }
- void cmd_gb_issubset(object &om, object &op)
- {
-   Matrix m = om->cast_to_Matrix();
-   gb_comp *p = op->cast_to_gb_comp();
-   int result = p->contains(m);
-   gStack.insert(make_object_int(result));
- }
- 
- void cmd_gb_isequal(object &op, object &oq)
- {
-   gb_comp *p = op->cast_to_gb_comp();
-   gb_comp *q = oq->cast_to_gb_comp();
-   int result = p->is_equal(q);
-   gStack.insert(make_object_int(result));
- }
  
  void cmd_comp_calc(object &ocomp, object &onsteps)
  {
--- 216,221 ----
***************
*** 325,373 ****
    gStack.insert(h->value());
  }
  
- void cmd_res(object &om, object &oalg, object &olength, object &odegree, object &ostrategy)
- {
-   Matrix m = om->cast_to_Matrix();
-   int alg = oalg->int_of();
-   int maxlev = olength->int_of();
-   int strategy = ostrategy->int_of();
-   intarray *deg = odegree->intarray_of();
-   int usedeg, maxdeg, origsyz;
-   res2_comp *p0;
-   res_comp *p1;
-   gbres_comp *p2;
-   if (deg->length() > 0)
-     {
-       usedeg = (deg->length() > 0);
-       maxdeg = (*deg)[0];
-     }
-   else
-     {
-       usedeg = 0;
-       maxdeg = 0;
-     }
-   switch (alg) {
-   case 0:
-     p0 = new res2_comp(m, maxlev, usedeg, maxdeg, strategy);
-     gStack.insert(p0);
-     break;
-   case 1:
-     p1 = new res_comp(m, maxlev, strategy);
-     gStack.insert(p1);
-     break;
-   case 2:
-     origsyz = m.n_cols();
-     p2 = new gbres_comp(m, maxlev+1, origsyz, strategy);
-     gStack.insert(p2);
-     break;
-   case 3:
-     origsyz = m.n_cols();
-     p2 = new gbres_comp(m, maxlev+1, origsyz, strategy | USE_HILB);
-     gStack.insert(p2);
-     break;
-   }
- }
- 
  
  void i_NGB_cmds(void)
  {
--- 303,308 ----
***************
*** 389,397 ****
    install(ggreduce, cmd_NGB_reduce, TY_GB_COMP, TY_MATRIX);
    install(ggreduce, cmd_NGB_vecreduce, TY_GB_COMP, TY_VECTOR);
  
-   install(ggissubset, cmd_gb_issubset, TY_MATRIX, TY_GB_COMP);
-   install(ggisequal, cmd_gb_isequal, TY_GB_COMP, TY_GB_COMP);
- 
    // Computation display/statistics
    install(ggtracing, cmd_NGB_tracing, TY_INT);
  
--- 324,329 ----
***************
*** 406,411 ****
    install(ggstats, cmd_hilb_stats, TY_HILB_COMP);
    install(gggetvalue, cmd_hilb_value, TY_HILB_COMP);
  
-   // Resolutions
-   install(ggres, cmd_res, TY_MATRIX, TY_INT, TY_INT, TY_INTARRAY, TY_INT);
  }
--- 338,341 ----
diff -c ./x_mat.cc /home2/mike/src/M/Macaulay2-0.8.12/e/x_mat.cc
*** ./x_mat.cc	Thu Apr 17 19:12:58 1997
--- /home2/mike/src/M/Macaulay2-0.8.12/e/x_mat.cc	Thu Jan  9 21:46:55 1997
***************
*** 378,390 ****
      *gError << "'koszul' expects a matrix with one row";
    }
  }
- void cmd_Matrix_koszul2(object &orows, object &ocols)
- {
-   Matrix rows = orows->cast_to_Matrix();
-   Matrix cols = ocols->cast_to_Matrix();
-   // Check: rings are all the same
-   gStack.insert(Matrix::koszul(rows,cols));
- }
  
  void cmd_Matrix_iden(object &oF)
  {
--- 378,383 ----
***************
*** 598,609 ****
    gStack.insert(new PfaffianComputation(M,p));
    engine_alloc(sizeof(PfaffianComputation));
  }
- void cmd_Matrix_simplify(object &om, object &on)
- {
-   Matrix M = om->cast_to_Matrix();
-   int n = on->int_of();
-   gStack.insert(M.simplify(n));
- }
  void cmd_Matrix_coeffs(object &om, object &op)
  {
    Matrix M = om->cast_to_Matrix();
--- 591,596 ----
***************
*** 966,972 ****
    install(ggsubmatrix, cmd_Matrix_submatrix1, TY_MATRIX, TY_INTARRAY);
  
    install(ggkoszul, cmd_Matrix_koszul, TY_MATRIX, TY_INT);
-   install(ggkoszul, cmd_Matrix_koszul2, TY_MATRIX, TY_MATRIX);
    install(gginitial, cmd_Matrix_initial, TY_MATRIX, TY_INT);
    install(gginitial, cmd_Matrix_initial1, TY_MATRIX);
    install(ggelim, cmd_Matrix_elim, TY_MATRIX, TY_INT);
--- 953,958 ----
***************
*** 1003,1010 ****
    install(ggpfaffs, cmd_pfaffs, TY_MATRIX, TY_INT);
  
    install(ggcoeffs, cmd_Matrix_coeffs, TY_MATRIX, TY_INTARRAY);
- 
-   install(ggsimplify, cmd_Matrix_simplify, TY_MATRIX, TY_INT);
  
    // ring map routines
    install(ggringmap, cmd_RingMap, TY_MATRIX);
--- 989,994 ----
