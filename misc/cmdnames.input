ggnone

ggEZZ
EZZ
. >> EPolynomialRing
Yields the ring ZZ, using the new arithmetic.

ggEcharp
Echarp
p:int >> EPolynomialRing
Yields the ring ZZ/p, using the new arithmetic.  p must be a positive integer, possibly not prime.  Currently, it is restricted to be less than 2^16-1.

ggadd
+
f g >> f+g
Add f and g. [type f, type g] = [vector,vector], [freemodule,freemodule], [matrix,matrix], [monideal,monideal], [ringelem,ringelem].  The sum of two free modules is their direct sum.

ggaddress
address
object >> int
Replace the object with an integer handle.  A reference count is increased, and so each such call must be matched with a call to ggforget.

ggautoreduce
autoreduce
m:matrix >> matrix
Given a matrix, whose lead terms are not divisible by one another, form the matrix whose i th column is the normal form of the i th column of m, w.r.t. the other columns of m.

ggbasisElement
basisElement
F:EFreeModule x:int >> EVector
Create the vector F_x, if x is in the range 0 <= x < rank(F), and return zero otherwise.

ggbetti
betti
res_comp >> intarray
Return an intarray in the same format as in 'ggpairs' describing the known minimal betti numbers of the resolution, as so far computed.  These numbers represent minimal bounds on the actual betti numbers.

ggbinomialGB
binomialGB
R:ring >> binomialGB_comp
Create a new GB computation for (possibly inhomogeneous) binomial ideals.  No syzygies are computed using this type of computation.  Add generators using ggbinomialGBaddgens, change the ring (enlarge it) using ggbinomialGBenlarge, perform computations using ggcalc, obtain results using gggetmingens, gggetgb, gggetsubring, gggetsubringGB.

ggbinomialGBaddgens
binomialGBaddgens
g:binomialGB_comp m:matrix >> .
If 'm' is a one row matrix having the same base ring as 'g', then add the entries of 'm' to the binomial ideal.  If 'm' is an n by m matrix of integers, where n is less than or equal to the number of variables of the base ring of 'g', then the columns are considered as binomials, and are added to the binomial ideal.  It is valid to add generators of lower degree than what has already been computed.

ggbinomialGBenlarge
g:binomialGB_comp R:ring >> .
Enlarges the base ring of 'g' to be 'R'.  The ring, its homogenity, and its term order should be consistent with the old values: The Groebner basis of the binomial ideal should not change.

ggborel
borel
mi:monideal >> monideal
Yield the smallest borel fixed monomial ideal containing 'mi'.

ggcalc
calc
computation >> int
Continue the computation on the stack until it is done, or until an interrupt occurs.  A return value of 

ggcharacteristic
characteristic
K:ECoefficientRing >> int
Returns the characteristic of the ring K.

ggcharp
charp
int >> ring
Create the prime field with the given characteristic.

ggcodim
codim
monideal >> int
Yields the codimension of the given monomial ideal.

ggcoeffs
coeffs
m:matrix vars:intarray >> coeffs:matrix monoms:matrix OR m:matrix >> coeffs:matrix monoms:matrix
Given an integer array 'vars' containing variable numbers from 0..numvars ring m-1, find the monomials in these variables, and their coefficients, placing these in the matrices 'coeffs' and 'monoms'.  For the second version: Let x_i be the smallest index variable that occurs in the 'j' th column of 'm'. Then the j th column of coeffs contains the (vector) coefficient of the highest power of this variable, and the j th element of monoms is x_i^n, if n is this highest power.

ggColumn2by2
column2by2
a1:RingElement a2:RingElement b1:RingElement b2:RingElement m:SparseMutableMatrix c1:int c2:int >> .
Modifies columns 'c1' and 'c2' of matrix 'm' as follows: column r1 is replaced with a1*(column c1)+a2*(column c2), and column c2 is replaced with b1*(column c1)+b2*(column c2).  The assignment to columns c1,c2 are performed simultaneously.

ggColumnAddMultiple
ColumnAddMultiple
m:SparseMutableMatrix c1:int a:RingElement c:int >> .
Destructively set m[column c] = m[column c] + a * m[column c1].

ggColumnInterchange
ColumnInterchange
m:SparseMutableMatrix c1:int c2:int >> .
Destructively interchange the two given columns of 'm'. 

ggColumnScale
ColumnScale
m:SparseMutableMatrix c:int a:RingElement >> .
Destructively set m[column c] = a * m[column c].

ggcompare
compare
a:monomial b:monomial >> int
Place -1,0,1, onto the stack, when a<b,a==b, and a>b, respectively.

ggconcat
concat
matrix_1 .. matrix_n n:int >> matrix
Concatenate the columns of all of these matrices together, forming a new matrix.  None of these matrices is itself modified (different behavior from Macaulay).  WARNING: the matrix is set to have the row degrees of the first matrix.  If any other matrix has more rows, there will be trouble.  Additionally, if the row degrees are not the same, then the column degrees will be screwed up as well.

ggcopy
copy
elem >> elem
Make a shiny new copy of the item on the top of the stack.

ggcontract
contract
m:matrix n:matrix >> matrix
Yields the matrix having the same shape as the tensor product, whose individual entries are the result of contracting (i.e. differentiate without using bringing down coefficients) entries of n by entries of m.

ggdeclarefield
declarefield
R:Ring >> .
Informs the engine that R is (probably) a field.  If at some point a zero divisor is found, then the engine flags that R is not a field, raises an error, and keeps a zero divisor stashed in the ring.  gggetzerodivisor retrieves this ring element.

ggdegree
degree
f:ringelem >> intarray;  OR  monomial >> int
(First form) Place the (multi-)degree of the lead term of f onto the stack. (Second form) Yields the sum of the exponents of the given monomial.

ggdenominator
denominator
f:ringelem >> g:ringelem
If f = g/h is an element of a fraction field frac(R), return the denominator h in R.

ggderef
deref
int >> object
Replace the integer handle with its corresponding object.

ggdets
dets
m:matrix p:int >> determinant computation
Create a computation which will yield the p by p minors of the matrix m.

ggdiff
diff
m:matrix n:matrix >> matrix
Yields the matrix having the same shape as the tensor product, whose individual entries are the result of differentiating entries of n by entries of m.

ggdim
dim
f:ring_elem >> ring_elem
Given a ring element, f, in a schur ring, replace each monomial with the dimension of the irreducible GL(n) representation having that monomial as highest weight, and return the resulting sum. (f is not modified).

ggdirectsum
m:matrix n:matrix >> matrix
Yields the direct sum (i.e. block sum) of the two matrices.

ggdiv
div
a:ringelem b:ringelem >> ringelem
Find a/b in the ring of a, b, if division is defined over this ring.

ggdivides
divides
a:monomial b:monomial >> int
Place 0, (or 1) onto the stack when a doesn't divide (does divide) b.

ggdivmod
divmod
a:ringelem b:ringelem >> d:ringelem m:ringelem
Find d = a/b and m = (a mod b) in the ring of a, b, if division is defined over this ring.

ggDOUBLE
double
>> RingElement
Read a double precision floating point number from the binary input stream, put it into the ring RR.

ggdrop
drop
vn .. v0 (n:int) >> v(n-1) .. v0
Remove the n th element from the stack.

ggdup
dup
v0 >> v0 v0
Push a copy of the top element on the stack.

ggduplicate
duplicate
vn .. v0 (n:int) >> vn .. v0 vn
Push a copy of the n th element on the stack.

ggelem
elem
v:Vector r:int >> RingElement;  OR  m:Matrix c:int >> Vector;  OR  m:Matrix r:int c:int >> RingElement OR m:SparseMutableMatrix r:int c:int >> RingElement
Vector version: yields the r th coefficient of the vector.  Matrix versions: Place either the c th column of the matrix, or the (r,c) th entry of the matrix onto the stack.

ggelim
elim
matrix n:int >> intarray
Yields an integer array having the indices of those columns of the matrix whose initial term is zero on the first n weight vectors.

ggev
ev
map:matrix source:matrix >> matrix
Evaluate the source matrix under the map sending the i th variable to the i th entry of map, where both indices count starting at zero.

ggexterior
exterior
F:freemodule d:int >> freemodule, OR m:matrix d:int >> matrix
Return the d th exterior power of F or m.

ggexteriorproduct
exteriorproduct
p:int q:int F:freemodule >> m:matrix
Return the matrix which represents the multiplication wedge(p)(F) ** wedge(q)(F) --> wedge(p+q)(F).

ggFFgausselim
M:SparseMutableMatrix >> p:intarray
Performs a fraction-free (Bareiss) Gaussian elimination on the columns of M (which is modified in place), the permutation integer array on the columns of M is returned.

ggfactor
factor
... >> ...
experimental

ggfactor1
factor
... >> ...
experimental

ggfactor2
factor
... >> ...
experimental

ggfindGoodUnitPivot
findGoodUnitPivot
m:SparseMutableMatrix c1:int c2:int >> r:int c:int
Find a unit (currently: only checks for 1, -1), m[r,c], which would minimize 'fill-ins', at least in the range of columns c1..c2.  If no 1 or -1 is found in the matrix in this range of columns, then r and c are both set to -1.

ggflip
flip
F:freemodule G:freemodule >> matrix
Yields the matrix representing the map F ** G --> G ** F.

ggforget
forget
h:int >> .
Remove a reference to the given integer handle.  This should match an original call to ggaddress.

ggfraction
fraction
R:Ring a:RingElement b:RingElement >> RingElement
Yields the element a/b in the fraction field R, if R is the fraction field of the rings of a and b.  If not, an error is returned.

ggfractionfield
fractionfield
R:ring >> K:field
Given a domain 'R', create its field of fractions, 'K'.

ggfree
free
V:vecinfo intarray >> freemodule;  OR  V:vecinfo n:int >> freemodule
Create a free module over the base ring of V which has as its degrees the entries of the intarray (first case), or has rank 'n', all of whose degrees are zero (second case).

ggfromdouble
fromdouble
R:Ring n:double >> RingElement
Return the double precision integer n as an element of R.  If R is not a ring over the reals RR, then n is coerved to an integer first, and then put into the ring R.

ggfromint
fromint
ring int >> ringelem
Return an element of the given ring with the given integer value.

gggb
gb
matrix >> gbasis; or matrix syztype:int n:int >> groebner_comp
Create a Groebner basis computation.

gggcd
gcd
a:ringelem b:ringelem >> g:ringelem; OR monomial monomial >> monomial;
Place the gcd of the two elements onto the stack, if gcd's are defined.

gggcdextended
gcdextended
a:ringelem b:ringelem >> g:ringelem x:ringelem y:ringelem
Return the greatest common divisor, g, of a and b, if gcd's are defined over this ring.  The following is satisfied: ax+by = g.

gggetchange
change
gbasis >> matrix
Return the change of basis matrix from the Groebner basis to another generating set, usually a minimal, or original, generating set.

gggetcoeff
getcoeff
f:ringelem m:monomial >> a:ringelem
Yields the (possibly zero) coefficient of the monomial 'm' in the polynomial 'f'.

gggetCoefficientRing
R:ERing >> ECoefficientRing
Returns the coefficient ring of R.

gggetColChange
getColChange
m:SparseMutableMatrix >> n:SparseMutableMatrix
Return the column operation recording matrix for 'm', if one has been set.  If not, an error is given.

gggetcols
getcols
matrix >> intarray
Place the column degrees of the matrix onto the stack.

gggetideal
getideal
R:ring >> I:matrix
If R is a quotient ring S/I, of a polynomial ring S, then place onto the stack the one row matrix consisting of the generators of a minimal GB of I.

gggetFreeModule
getFreeModule
v:EVector >> EFreeModule
Returns the free module which contains the vector v.

gggetgb
getgb
gbasis >> matrix
Place the Groebner basis (as far as it has been computed) onto the stack.

gggetMO
getMO
M:EMonoid >> EMonomialOrder
Returns (a copy of) the monomial order in M.

gggetMonoid
getMonoid
R:ERing >> EMonoid
Returns the monoid used to construct the (polynomial) ring R.

gggetmingens
getmingens
gbasis >> matrix
Place the matrix whose columns are minimal generators of the submodule with the given Groebner basis (at least as it has so far been computed).

gggetring
getring
var >> ring
Place the base ring of the given variable onto the stack.  If that variable does not have a base ring (e.g. an int), then put the current ring onto the stack.

gggetRingFreeModule
getRingFreeModule
R:ERing >> EFreeModule
Returns the free module R^1.

gggetRowChange
getRowChange
m:SparseMutableMatrix >> n:SparseMutableMatrix
Return the row operation recording matrix for 'm', if one has been set.  If not, an error is given.

gggetColumnChange
getColumnChange
m:SparseMutableMatrix >> n:SparseMutableMatrix
Return the column operation recording matrix for 'm', if one has been set.  If not, an error is given.

gggetrows
getrows
matrix >> intarray
Place the row degrees of the given matrix onto the stack.

gggetshift
getshift
matrix >> intarray
Yields the (multi-)degree of the matrix.

gggetsubring
getsubring
g:binomialGB_comp n:int >> m:matrix
Yields a generating set for the subideal of the given binomial ideal whose first 'n' wieght vectors are zero.  This will often be a minimal generating set, if that is computed during the GB computation.

gggetsubringGB
getsubringGB
g:binomialGB_comp n:int >> m:matrix
Yields a one row matrix whose entries form the Groebner basis of the given binomial ideal, as so far computed.

gggetsyz
getsyz
gbasis >> matrix
Place the (non-minimal) syzygy matrix computed in gbasis onto the stack.

gggetterms
getterms
ringelem lo:int hi:int >> ringelem;  OR  vector lo:int hi:int >> vector
Yields the sum of all terms within the given indices (inclusive).  If either lo or hi is less than zero, then they refer to the last indices.  For example, if lo=-3, and hi=-1, then this chooses the last three monomials of a polynomial.

gggetvalue
getvalue
h:hilb_comp >> ringelement
Yields the so-called Poincare polynomial (the numerator of the Hilbert series) if the computation has been completed.  If the computation is not yet complete, an error is issued.

gggetzerodivisor
getzerodivisor
R:Ring >> RingElement
If the ring R has been found to have a zero divisor, this yields that element.  If not, the zero element is returned.

ggrandom
random
F:freemodule G:freemodule n:int deg:intarray >> matrix  OR  R:ring >> ringelem
Return a matrix of degree 'deg' between graded free modules F <-- G.  If 'n' is less than zero,
then a homogeneous matrix is returned.  NEEDS WORK!!

ggrandomint
randomint
n:int >> int
Return a random integer in the range 0..n-1, where n is positive arbitrary precision integer.  The algorithm used is described briefly in the documentation for ggrandomseed.

ggrandommax
randommax
n:int >> int
Set the maximum integer value that ggrandom or ggrandomint will return.  Random rational numbers will have both numerator and denominator bounded by this value.  The returned value is the current bound.

ggrandomseed
randomseed
n:int >> .
Set the random number generator seed to the given number. The seed is initially set to zero.  The random generator currently used is the 'minimal' random generator of Park and Miller, described in the book 'Numerical recipes in C'.  Currently only the low 32 bits of 'n' are used for the seed.

ggrank
F:EFreeModule >> int
Returns the rank of the free module F.

ggreducepivots
reducePivots
m:SparseMutableMatrix >> SparseMutableMatrix
Takes a matrix, reduces all possible pivots, and returns the compressed matrix.

ggremote
remote
matrix mach:string user:string s:string cmd:string >> remote_gb_comp
Create a remote Groebner basis computation.  In development.

gghash
f:object >> int
Returns an integer hash(f) (usually 32 bit, signed) such that given two objects f and g, f==g implies that hash(f) == hash(g).

ggheap
heap
. >> string
Push a string containing the types of the heap elements.

gghermite
hermite
m:matrix collectsyz:int ncomps:int >> hermite_computation
Create the computation of the Hermite normal form of the matrix 'm' over the integers.  This is essentially a Groebner basis for the submodule of Z^n generated by the columns of 'm'.  The elements 'collectsyz' and 'ncomps' have the same meaning that they have for Groebner basis computations.

gghilb
hilb
R:ring matrix >> denom:ring_elem numer:ring_elem; OR  R:ring monideal >> ring_elem
Compute the numerator of the Hilbert series (the Poincare polynomial) of the given monomial ideal, or of the monomial submodule generated by the initial terms of the given matrix. The result is a ring element in the ring R, involving the first 'd' variables in that ring, where 'd' is the size of the degree vector.  In the first form, because the degrees of the rows may be negative, the first result is a monomial for which numer/denom is the Poincare polynomial.

gghomogenize
homogenize
m:matrix n:int >> matrix
Homogenize the given matrix using the n th variable in the ring to homogenize.  An error is given if the resulting matrix cannot be made (multi-)homogeneous.  The matrix m could also be a ring element.

gghomogenize1
homogenize1
m:ring_elem deg:intarray n:int >> ring_elem
Homogenize the given ring element using the n th variable in the ring to homogenize.  An error is given if the resulting matrix cannot be made (multi-)homogeneous.  The degree 'deg' is the target degree.

ggiden
iden
F:freemodule >> matrix
Place the identity matrix F --> F onto the stack.

ggindex
index
array int >> var,  or  intarray int >> int
Place the given element of the given array onto the stack.

gginitial
initial
m:matrix w:int >> matrix;  OR  gbasis n:int >> monideal.
Return the matrix of initial forms of m.  The initial term of a vector consists of those monomials which have the same value as the lead monomial on the first 'w' weight vectors.  w=-1 gives the usual lead term. The second form returns the monomial ideal of initial forms which occur in the n th row.

ggINT
int
>> int
Read an integer from the binary input stream.

ggINTARRAY
intarray
>> intarray
Read an integer array from the binary input stream.  The format is: the length, followed by each entry.  Each of these integers is also in the binary format.

ggintersect
intersect
monideal monideal >> monideal
Place the intersection of the two monomial ideals onto the stack.

ggisborel
isborel
mi:monideal >> int
Return whether 'mi' is a borel fixed monomial ideal.

ggisequal
isequal
f g >> bool [type of f,g is ringelem, vector, freemodule, matrix, gbcomp, monideal, monomial, ring]
Yields true(1) or false(0) depending on whether f and g are equal.

ggisequal0
isequal0
f:object g:object >> bool
Return whether f and g are equal.  For this function, equality is defined as follows: f and g can only be equal if they have exactly the same type in the engine, and if so, they must point to the exact same object, except in the cases when the common type is: RingElement, Monomial, and Vector.  In these cases, equality is checked as in ggisequal: they must be the same element in the same (as defined above) ring or free module.  This routine exists to allow ring elements and vectors to be used as keys in hashtables.

ggishomogeneous
ishomogeneous
f >> bool  [f is a ringelem, vector, or matrix]
Yields true(1) or false(0), depending on whether 'f'is (multi-)homogeneous.  If the base ring is not homogeneous, then this will always yield false.

ggissubset
subset
m:matrix gb:gbcomp >> int
If some column of the matrix 'm' does not reduce to zero w.r.t. gb, return the index of the first such column, otherwise return -1.

ggiszero
iszero
a:ringelem >> int
Place a 1 on the stack if a is zero, otherwise place a 0 on the stack.

ggkbasis
kbasis
top:matrix bottom:matrix d:deg >> matrix
Form a matrix whose columns form a k-basis of the module (image(top)/image(bottom)) in degree d.  It is assumed that the columns of 'top' and 'bottom' form Groebner bases, and that they have the same row space.  If d = {}, then a k-basis for the whole module is returned.

ggkbasisIn
kbasisIn
m:matrix deg:intarray >> matrix
Yields a matrix 'n' such that 'm n' is a matrix whose columns form a k-basis for the submodule image(m) in degree 'deg'.  If 'm' is not a Groebner basis, then this set generates image(m) in degree 'deg', but may not be independent.

ggkbasisOut
kbasisOut
m:matrix deg:intarray >> matrix
Yields a matrix consisting of monomials such that the columns consist of all monomials of degree 'deg' that are not in the monomial submodule of lead terms of the matrix 'm'.

ggker
ker
matrix h:int >> gbasis
Create a Groebner basis computation to compute the first h components of each syzygy of the given matrix.

ggkoszul
koszul
M:matrix p:int >> matrix
Place the p th koszul matrix of M onto the stack.  M should be a matrix with exactly one row.

gglcm
lcm
monomial monomial >> monomial
Place the l.c.m. othe the two monomials onto the stack.

gglength
length
object >> int
Yields the length of the given object.  The definition of length is type specific.  For example, for polynomials it is the number of non-zero monomials, for vectors it is the number of non-zero components, for freemodules it is the rank, and for matrices it is the number of columns.

ggleadcoeff
leadcoeff
f:ringelem >> ringelem
Place the coefficient of the lead term onto the stack.  Its base ring is the coefficient ring of the base ring of f, if f is a polynomial.

ggleadcomp
leadcomp
f:vector >> int
Returns the lead component of the non-zero vector f.

ggleadmonom
leadmonom
ringelem >> ringelem
Place the lead monomial (with coefficient 1) onto the stack.

ggleadterm
leadterm
ringelem >> ringelem
Place the lead term (coefficient plus monomial) onto the stack.

gglift
lift
S:ring f:ringelem >> g:ringelem
Lift f to an element g of S.  If R is the base ring of f, then S ---> R should be one of the following extensions: (1) R ---> R (in which case f is returned without change), (2) S ---> R=S/I, (in which case f can always be lifted: note that S itself may be a quotient base ring of R), (3) S ---> R=S[x1..xn], (an error is returned if f is not a scalar), (4) S ---> R=frac S, (an error is returned if f is not an element of S), (5) S=Z/p[x]/(F(x)) ---> GF(p,n).  An error indication is returned if the ring extension is not one of these, or in the situations indicated.

ggLLLinit
LLLinit
m:Matrix threshold:RingElement flag:int >> A:SparseMutableMatrix LLLstate:SparseMutableMatrix
Setup the computation of the LLL reduction of the matrix 'm' (over ZZ).  There is no engine LLL computation object.  Instead, the answer will appear in 'A' (after using ggLLLcalc), using the internal state 'LLLstate'.  The threshold should be an element of ZZ or QQ, in the range (1/4, 1].  If flag is non-zero, then the change of basis column multiplier matrix for 'A' is set.  After the computation is complete (or before, to view the partial answer), this multiplier matrix B can be obtained using gggetColChange on A.  The final answers satisfy: A = m*B.  For more information about LLL reduction, see H. Cohen, A Course in Computational Algebraic Number Theory, Springer Lecture notes in Math, 138.

ggLLLcalc
LLLcalc
A:SparseMutableMatrix LLLstate:SparseMutableMatrix nsteps:int >> int
Compute the LLL reduction of the matrix A, using the state setup originally by ggLLLinit.  Compute 'nsteps' amount.  If this is -1, compute until done, or interrupted.  See the documentation for ggLLLinit for more information.  Return values: if an error: -2 (e.g. the columns of 'A' are not independent), if completely done: 0, if interrupted: -1, if done with the given number of steps, but not completely done: 9.

ggmatrix
matrix
v0 v1 ... v(c-1) rows:freemodule cols:freemodule >> matrix;  OR  v0 v1 ... v(c-1) rows:freemodule c:int >> matrix;  OR  vecinfo monideal >> matrix
In the first two forms, create a matrix having the given rows, and the columns of the matrix are v0, ..., v(c-1).  In the first form, the column free module is set to 'cols', while in the second form, the column degrees are computed.  The third form creates a one row matrix whose entries are the monomials in the given monomial ideal.

ggmem
mem
. >> .
Place some user readable memory usage information onto the output string.

ggminleadterms
minleadterms
m:matrix >> intarray
Returns the indices of the columns of 'm' whose lead terms minimally generate the lead monomial, or term, submodule.

ggmod
mod
a:ringelem b:ringelem >> ringelem
Compute the remainder of dividing a by b, if division is defined in the ring of a and b.

ggmodtensor
modtensor
m:matrix n:matrix >> matrix
Yields a matrix which presents coker(m) tensor coker(n).

ggmonideal
monideal
M:matrix n:int >> monideal
Return the monomial ideal of those columns of M whose lead terms are in row n.

ggmonoid
monoid
n:int degrees:intarray weights:intarray
Create a monoid having n variables, which has the gradings from 'degrees' and the ordering from 'weights'

ggMOclone
MOclone
mo:MonomialOrder >> mo':MonomialOrder
Create a new copy of 'mo'.

ggMOcomponent
MOcomponent
mo:MonomialOrder >> .
While creating a monomial order, place the component as the next slot.

ggMOelim
MOelim
mo1:mon_order mo2:monorder >> monorder
Form the product elimination order.

ggMOinit
MOinit
. >> MonomialOrder
Start the creation of a MonomialOrder.  One must then call a sequence of the routines: ggMOclone, ggMOrevlex, ggMOlex, ggMOcomponent, ggMOwtfcn, ggMOproduct, ggMONClex.

ggMOgeneral
MOgeneral
d:intarray order:intarray invorder:intarray invdegs:intarray >> monorder
Create an engine 'mon_order', where 'd' is a (totally positive) vector of length 'n' of degrees, 'order' is a flattened n by n matrix of integers giving the order (i.e. given two monomials having exponent vectors m1, m2, then m1 > m2 iff (order*m1) > (order*m2) in the lexicographic order.  'invorder' is a (flattened) integral matrix such that (order * invorder == diagonal matrix whose entries are 'invdegs'.

ggMOglex
MOglex
d:intarray >> monorder
Create an engine 'mon_order', which is graded lex order on a set of variables, where 'd' consists of the degrees of these variables.

ggMOgproduct
MOgproduct
mo1:mon_order mo2:monorder >> monorder
Form the graded product order.

ggMOgrevlex
MOgrevlex
d:intarray >> monorder
Create an engine 'mon_order', which is graded reverse lex order on a set of variables, where 'd' consists of the degrees of these variables.

ggMOlex
MOlex
d:intarray >> monorder
Create an engine 'mon_order', which is lex order on a set of variables, where 'd' consists of the degrees of these variables.

ggMONClex
MONClex
mo:MonomialOrder nvars:int >> .
Append a block of non-commuting 'nvars' variables as the next part of the monomial order.  The order in this block is the lexicographic order.

ggMOproduct
MOproduct
mo1:mon_order mo2:monorder >> monorder
Form the product order.

ggMOrevlex
MOrevlex
d:intarray >> monorder
Create an engine 'mon_order', which is (non-graded) reverse lex order on a set of variables, where 'd' consists of the degrees of these variables.

ggMOwtfcn
MOwtfcn
degs:intarray wtfcn:intarray >> monorder
Form the monomial order which is graded using 'degs'.  MES

ggMONOMIAL
monomial
monoid >> monomial
Read from the input stream a monomial which is in the binary format (i.e. the number of variable/exponent pairs, followed by the sequence of variables and exponents.  Each of these integers is also in the binary format.

ggmonsyz
monsyz
matrix >> matrix;  a:monomial b:monomial >> c:monomial d:monomial
In the first case, place the monomial syzygies on the lead terms of the given matrix onto the stack.  For monomials, place the monomials c, d onto the stack, where a c = b d = lcm(a,b).

ggmult
*
f g >> f*g: 
Multiply f and g.  If f and g are free modules, then the result is the tensor product. [type,f,type g] = [ringelem,vector], [vector,ringelem], [ringelem,matrix], [matrix,matrix], [matrix,vector], [monideal, monideal], [monomial,monomial], [ringelem, ringelem], [freemodule, freemodule].

ggnegate
negate
matrix >> matrix
Place the negation of the given matrix onto the stack.

ggnmonoms
nmonoms
res_comp >> intarray
Return an intarray in the same format as in 'ggpairs' describing the number of monomials present in each level/degree of the resolution.

ggnumcols
numcols
m:SparseMutableMatrix >> int
Yields the number of columns of 'm'.

ggnumerator
numerator
f:ringelem >> g:ringelem
If f = g/h is an element of a fraction field frac(R), return the numerator g in R.

ggnumrows
numrows
m:SparseMutableMatrix >> int
Yields the number of rows of 'm'.

ggnvars
nvars
M:EMonoid >> int
Returns the number of variables in M.

ggpairs
pairs
res_comp >> intarray
Return an intarray describing upper bounds on the graded betti numbers.  Equivalently, these numbers represent the number of S-pair computations that have been/or will be computed.  The format for this array is: [low degree, high degree, max level, b0, b1, ...], where the betti numbers have been flattened by rows.  Thus, b_((i-lo)*len + lev) gives the number of elements at level 'lev' in slanted degree 'i', where lo, hi, len are the first three elements in the output intarray.

ggpermute
permute
m:SparseMutableMatrix lo:int hi:int perm:intarray >> .
Permute the columns lo..hi of 'm' using the elements perm[0]..perm[hi-lo+1].  That is, column c is moved to column perm[c-lo].

ggpfaffs
pfaffs
m:matrix p:int >> pfaffian computation
Create a computation which will yield the p by p pfaffians of the skew symmetric matrix m.

ggpick
pick
vn v(n-1) ... v1 v0 (n:int) >> v(n-1) ... v1 v0 vn 
Move the n th element to the top of the stack.

ggpolyring
polyring
ring monoid >> ring
Create the polynomial ring (i.e. monoid ring) wirh coefficients from the given ring, and monomials from the given monoid.

ggpop
pop
v1 v0 >> v1
Remove the top element from the stack.

ggpoppem
poppem
v(n-1) ... v1 v0 n:int >> .
Remove the top n elements from the stack.

ggpower
^
f:ringelem n:int >> ringelem
Place f^n onto the stack.  If f is a polynomial, the binomial method is used to compute the exponent.

ggprimes
primes
monideal >> monideal
Yields a monomial ideal whose monomials are in one to one correspondence with the associated primes of minimal codimension.  Each monomial corresponds to the prime monomial ideal generated by the variables its support.

ggpromote
promote
R:ring f:ringelem >> g:ringelem
Promote f to an element g of R.  If S is the base ring of f, then S ---> R should be one of the following extensions: (1) R ---> R (in which case f is returned without change), (2) S ---> R=S/I, (3) S ---> R=S[x1..xn], (4) S ---> R=frac S, (5) S=Z/p[x]/(F(x)) ---> GF(p,n).  An error indication is returned if the ring extension is not one of these.

ggqring
qring
I:matrix >> R:ring;  OR f1 ... fn n A:ring >> R:ring
Create the ring R = A/I, where A is the ring of I, and I is a 1 by r matrix with entries in the polynomial ring (or quotient of a polynomial ring) A.  In the second version I is the ideal generated by the f1, ..., fn, which should be elements of A.  Currently, in either case the generators should form a Groebner basis, whose lead terms are all monic.

ggquit
quit
. >> .
Quit the engine

ggradical
radical
monideal >> monideal;  OR  monomial >> monomial.
Yields the radical of the given monomial (ideal).

ggreduce
reduce
gbasis matrix >> red:matrix lift:matrix
Reduce the given matrix using the Groebner basis, obtaining the matrix red.  The matrix lift is the corresponding matrix.  MES ************* improve this.

ggremaining
remaining
res_comp >> intarray
Return an intarray describing the number of S-pair computations that remain to be computed.  The format for the array is that of 'ggpairs'.

ggringmap
ringmap
m:matrix >> f:ringmap;  OR  I:ideal >> f:ringmap
Create a ring map f : (any ring S) --> (ring m).  The i th variable of S is mapped to the i th element of (the first row of) m, or the i th element of I, using the engine command 'ggev'.

ggreceive
receive
remote_gb_comp >> matrix
Return the Groebner basis matrix so far computed with the remote GB routine.  In development.

ggremove
remove
monideal >> int monomial
Remove the lexicographically largest element from the monomial ideal.  Place its integer number and the actual monomial onto the stack.  If the monideal is empty, raise an error.

ggres
res
m:matrix >> res_comp
Create a computation to compute the free resolution of m.  The computation itself should be done using ggcalc or ggcalc1.

ggreshape
reshape
m:matrix F:freemodule G:freemodule >> matrix
Yields the matrix obtained from 'm' of shape F <--- G, by taking elements from the first row of 'm', then the second, and so on, filling them into the result row by row.  Currently, it is assumed that 'm' and the result both have the same number of entries.

ggresmap
resmap
gr:res_comp i:int >> matrix
Return the i th matrix of the (minimal) resolution 'gr'.

ggresmodule
resmodule
gr:res_comp i:int >> freemodule
Return the i th free module of the (minimal) resolution 'gr'.

ggresNmap
resNmap
gr:res_comp i:int >> matrix
Return the i th matrix of the (possibly non-minimal) resolution 'gr'.

ggresNmodule
resNmodule
gr:res_comp i:int >> freemodule
Return the i th free module of the (possibly non-minimal) resolution 'gr'.

ggrightmult
rightmult
v:EVector w:EVector >> EVector
Return v*w, where the component is taken from v.

ggRow2by2
row2by2
a1:RingElement a2:RingElement b1:RingElement b2:RingElement m:SparseMutableMatrix r1:int r2:int >> .
Modifies rows 'r1' and 'r2' of matrix 'm' as follows: row r1 is replaced with a1*(row r1)+a2*(row r2), and row r2 is replaced with b1*(row r1)+b2*(row r2).  The assignment to rows r1,r2 are performed simultaneously.

ggRowAddMultiple
RowAddMultiple
m:SparseMutableMatrix r1:int a:RingElement r:int >> .
Destructively set m[row r] = m[row r] + a * m[row r1].  Note: this is less efficient than the corresponding column operation.

ggRowInterchange
RowInterchange
m:SparseMutableMatrix r1:int r2:int >> .
Destructively interchange the two given rows of 'm'.  Note: this is less efficient than the corresponding column operation.

ggRowScale
RowScale
m:SparseMutableMatrix r:int a:RingElement >> .
Destructively set m[row r] = a * m[row r]. Note: this is less efficient than the corresponding column operation.

ggRR
RR
. >> Ring
Place the ring of real numbers (implemented as arithmetic on double precision floating point numbers) onto the stack.

ggsagbi
sagbi
m:matrix >> sagbi_comp
Creates a computation node for computing a sagbi basis of the subalgebra generated by the entries of the one row matrix m.  The usual gb_comp routines, such as ggcalc, gggetgb, etc. all work for this computation node.

ggsat
sat
I:monideal m:monomial >> monideal;  OR  I:monideal J:monideal >> monideal;  OR m:monomial n:monomial >> monomial.
Yields the saturation (I:m^*), or (I:J^*).

ggschur
schur
K:ring M:monoid >> R:ring
Create the ring R = K[M], where each monomial is thought of as representing an irreducible GL(n)-module, where n is the number of variables of the monoid M.  Multiplication is the multiplication of schur functors, and is implemented using a variant of the Littlewood-Richardson rule.

ggsearch
search
ti:TermIdeal m:Matrix >> Matrix
This is a debug routine: given a matrix with one row, return a matrix with the same number of columns as 'm', each column being the result of applying 'search' to the lead term of that column of 'm'.

ggsee
see
string >> .
Place this string onto the output stream.

ggselect
select
v:vector F:freemodule a:intarray >> vector
Yields a vector w in F: w = v_(a_0) F_0 + ... v_(a_r-1) F_(r-1), where r is the length of 'a', which should be less than or equal to the rank of 'F'.

ggsend
send
remote_gb_comp >> .
Send the generators to the remote machine. In development.

ggsetColChange
setColChange
m:SparseMutableMatrix n:SparseMutableMatrix >> .
Set 'm' to record column operations in the matrix 'n'.  The matrix 'n' should have the same number of columns as 'm' has columns. (Thus, each time a column operation is performed on 'm', it is also performed on 'n'.

ggSetEntry
setEntry
m:SparseMutableMatrix r:int c:int a:RingElement >> .
Set m[r,c] := a, assuming that the ring of 'a' is the same as the ring of 'm', and the indices are in range.

ggsetRowChange
setRowChange
m:SparseMutableMatrix n:SparseMutableMatrix >> .
Set 'm' to record row operations in the matrix 'n'.  The matrix 'n' should have the same number of columns as 'm' has rows.  Thus, each time a row operation is performed on 'm', the corresponding column operation is performed on the matrix 'n'.

ggsetshift
setshift
m:matrix d:intarray >> .
Set the degree of the map 'm' to be the degree 'd'.  The source and target free modules of the matrix are not changed (and so the result may no longer be graded).

ggshift
shift
F:freemodule a:intarray >> freemodule
Return the graded free module F(a), where the length of a should be the number of degree vectors in the base ring of F.

ggsimplify
simplify
m:matrix n:int >> matrix
Simplify the columns of the matrix 'm' in a way depending on the number 'n': if n=1, remove zero columns. if n=2, remove elements which are scalar multiples of others, and zeros, if n=3, remove columns which are divisible by other columns. Larger n will be possible as well: for example, one will be able to auto-reduce a set of columns, or remove monomial multiples, or replace with square-free elements.

ggskeleton
skeleton
r:res_comp >> .
Compute the skeleton of the resolution.  This is a debugging facility.  To see the number of pairs, use ggpairs after this, or grab the lead terms by using ggresNmap.

ggskewpolyring
skewpolyring
K:ECoefficientRing M:EMonoid skews:intarray >> ESkewPolynomialRing
Create the ring K[M], where multiplication is skew commutative for the variables in the 'skews' array.  All variables not in this list commute with all variables, whereas for variables x,y, in the list 'skews', x^2 = 0 and x*y = -y*x.

ggSmithNormalForm
SmithNormalForm
m:matrix n:int >> SmithNormalFormComputation
Create a computation to compute the Smith normal form for the matrix 'm'.  The base ring of 'm' should be a computable PID, e.g. ZZ or k[x], where k is a field.  If 'n' is non-zero, then enough information is collected to give the isomorphism matrix from the cokernel of the smith normal form matrix to the cokernel of 'm'.  As usual with computations, 'ggcalc' is used to perform the computation.  'gggetchange' gets the matrix representing this isomorphism (the change of basis matrix), assuming that the parameter 'n' is non-zero.  'gggetgb' returns the matrix whose cokernel is isomorphic to coker m.  If the computation is not complete, an intermediate value is returned.  Finally, 'ggstatus' returns an integer representing the current status of the computation.  (0 = computation is complete).

ggsortcolumns
sortcolumns
m:matrix degorder:int monorder:int>> intarray  OR m:SparseMutableMatrix lo:int hi:int >> intarray
Return an integer array giving the permutation of columns required to sort the columns of 'm'. The order used is determined from the signs of degorder, monorder: if degorder is positive (negative), then the columns are sorted into ascending (descending) degree order.  If degorder is 0, or for columns having the same degree, if monorder is positive (negative), then these columns are sorted in ascending (descending) monomial order.  SECOND FORM: sort the columns lo..hi of 'm', and return the resulting permutation in the result, which is an array of length hi-lo+1.  The sort order used is: zero vectors are least, then the row of the lead term is considered (higher lead terms are sorted later), finally, if the coefficients are ZZ, the absolute value is considered, or, if this is a polynomial ring, the (simple) degree is considered, with larger values sorted later. (CURRENTLY: no intarray is returned: the sort is simply performed 6/30/98).

ggsparsematrix
sparsematrix
R:ring r:int c:int >> SparseMutableMatrix OR m:Matrix >> SparseMutableMatrix
Create a so-called sparse matrix.  In the first case, the matrix is set to the zero r by c matrix over the ring R.  In the second case, the matrix is set to the matrix 'm', using a different representation.  This representation stores only non-zero components, and for each component, the entire ring element is stored as one element (this is different than the order required by the Groebner basis routines).  Routines that act on these SparseMutableMatrix's include: ggelem, ggset, ggRowInterchange, ggColumnInterchange, ggRowAddMultiple, ggColumnAddMultiple, ggRowScale, ggColumnScale.

ggsparsevector
sparsevector
nothing yet
nothing yet

ggstack
stack
. >> string
Push a string containing the types of the stack elements.

ggstats
stats
gb_comp >> .;  OR res_comp >> .
Return a string describing the state of the Groebner or resolution computation, and the number of S-pair and generator computations remaining in each degree.

ggstatus
status
SmithNormalFormComputation >> int OR ...
Return an integer describing the state of the computation: 0 means the computation is done.  Any non-zero value means that the computation is not complete.

ggSTRING
string
(string from input) >> string
Place a string on the stack.

ggsubduction
subduction
m:matrix F:ringmap J:GB >> matrix
Given a (partial) SAGBI basis which is the image of the map F, and the GB J of the ideal (y_i - in(f_i)), computed in degrees at least as high as the elements of 'm', return the (auto) subduction of the one row matrix 'm'.

ggsubmatrix
submatrix
rows:intarray cols:intarray M:matrix >> matrix
Return the matrix obtained from M by choosing the given rows and columns in the specified order.

ggsubmodule
submodule
F:freemodule rows:intarray >> freemodule
Return the freemodule obtained by taking the basis elements of F given by rows[0], rows[1], ... rows[length(rows)-1].

ggsubtract
-
a:var b:var >> var
Place a-b onto the stack.

ggsymm
symm
F:freemodule d:int >> freemodule;  OR m:matrix d:int >> matrix
Yields the d th symmetric power of the first argument.  Currently, the matrix argument must have only one row.

ggtensor
tensor
matrix matrix >> matrix
Return the tensor product ('outer' in Macaulay) of the two matrices.

ggterm
term
polyring a:ringelem m:monomial >> ringelem;  OR freemodule a:ringelem i:int >> vector
Create a polynomial from a coefficient and a monomial (first case), or create a vector from a ring element and an integer component (second case).

ggtermideal
termideal
m:matrix n:int >> termideal
Given a matrix defined over a ring R = Z[x1..xn]/I, create the termideal of lead terms which occur in the 'i'th row of this matrix.

ggtest
test
. >> .
Run some debugging code.  Internal use only.

ggtonet
tonet
var >> string
Place onto the stack a string representation of var suitable for dumping to a disk or network (using the command netsee).

ggtostring
tostring
var >> string
Place a reasonably readable string representation of the object onto the stack.

ggtracing
tracing
int >> int
Set the amount of tracing output done by GB routines (0 = none), and return on the stack the current tracing value.

ggtranspose
transpose
matrix >> matrix
Return the (graded) transpose of the given matrix.

ggtruncate
truncate
to do
to do

ggisunit
unit
f:ringelem >> int
If f is a unit, place 1 on the stack, else place a 0.

ggvar
var
xring v:int e:int >> ringelem
Place the monomial x^e onto the stack, where x is the v th variable in the given ring.

ggvector
vector
vecinfo f0:ringelem f2:ringelem ... f(r-1):ringelem >> vector
Create the vector f0 <0> + f1 <1> + ... + f(r-1) <r-1> using 'vecinfo'.

ggweylalgebra
weylalgebra
k:field M:monoid a:intarray >> ring
Create the ring of differential operators (the Weyl algebra), whose underlying commutative polynomial ring is k[M], and where the differential operators are given by 'a'. (E.g. a = {0,2,1,3} associates variable 2 to be the differential operator corresponding to the variable 0, var 3 is the diff op corresponding to var 1, etc.  A negative value signifies that the corresponding diff op, or commutative variable, is not present.

ggGF
GF
p:int n:int >> ring
Create the finite field having p^n elements, where p is a prime number.

ggZ
Z
. >> ring
Place the ring of integers onto the stack.

ggZn
Zn
n:int >> monoid
Yields the monoid Z^n, where each entry must fit into a machine integer.

ggzero
zero
F:freemodule >> vector
Yields the zero vector of F.

ggzeromat
zeromat
rows:freemodule cols:freemodule >> matrix
Place the zero matrix cols --> rows onto the stack.  

ggzeromonoid
zeromonoid
. >> monoid
Returns the trivial monoid with a single element.
