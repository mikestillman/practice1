-- generated by scc1

signature tokens (
     use system;
     use err;
     use stdio;
     use stdiop;
     use strings;
     use nets;
     use arithmetic;
     import parsefuns:={unary:function(Token,TokenFile,int,bool):ParseTree,binary:function(ParseTree,Token,TokenFile,int,bool):ParseTree};
     import parseinfo:={precedence:int,scope:int,strength:int,funs:parsefuns};
     import TCnone:int;
     import TCid:int;
     import TCint:int;
     import TCdouble:int;
     import TCstring:int;
     import Word:={name:string,typecode:int,hash:int,parse:parseinfo};
     import Symbol:={word:Word,hash:int,position:Position,unary:unop,postfix:unop,binary:binop,scopenum:int,frameindex:int,lookupCount:int,protected:bool,transientScope:bool,flagLookup:bool};
     import SymbolListCell:={entry:Symbol,next:SymbolList};
     import SymbolList:=(null or SymbolListCell);
     import SymbolHashTable:=array(SymbolList);
     import newSymbolHashTable(size:int):SymbolHashTable;
     import Dictionary:={hashTable:SymbolHashTable,numEntries:int};
     import Scope:={dictionary:Dictionary,outerScope:Scope,seqno:int,framesize:int,transient:bool};
     import Token:={word:Word,position:Position,scope:Scope,entry:Symbol};
     import Adjacent:={lhs:ParseTree,rhs:ParseTree};
     import While:={whiletoken:Token,predicate:ParseTree,dotoken:Token,body:ParseTree};
     import TryElse:={trytoken:Token,primary:ParseTree,elsetoken:Token,alternate:ParseTree};
     import Try:={trytoken:Token,primary:ParseTree};
     import IfThen:={iftoken:Token,predicate:ParseTree,thentoken:Token,thenclause:ParseTree};
     import IfThenElse:={iftoken:Token,predicate:ParseTree,thentoken:Token,thenclause:ParseTree,elsetoken:Token,elseclause:ParseTree};
     import New:={newtoken:Token,newclass:ParseTree,oftoken:Token,newparent:ParseTree,fromtoken:Token,newinitializer:ParseTree};
     import Arrow:={lhs:ParseTree,operator:Token,rhs:ParseTree,desc:functionDescription};
     import Quote:={operator:Token,rhs:Token};
     import GlobalQuote:={operator:Token,rhs:Token,global:void};
     import LocalQuote:={operator:Token,rhs:Token,local:void};
     import Binary:={lhs:ParseTree,operator:Token,rhs:ParseTree};
     import Unary:={operator:Token,rhs:ParseTree};
     import Postfix:={lhs:ParseTree,operator:Token};
     import ArrayParseTree:=array(ParseTree);
     import parenthesized:={left:Token,contents:ParseTree,right:Token};
     import parentheses:={left:Token,right:Token};
     import dummy:={position:Position};
     import startScope:={scope:Scope,body:ParseTree};
     import ParseTree:=(Token or Adjacent or Binary or Unary or Postfix or parenthesized or parentheses or IfThen or IfThenElse or startScope or Quote or GlobalQuote or LocalQuote or TryElse or Try or While or Arrow or New or dummy);
     import TokenFile:={posFile:PosFile,last:(null or Token)};
     import isatty(f:TokenFile):bool;
     import Real:={v:double};
     import CompiledFunction:={fn:fun,hash:int};
     import CompiledFunctionClosure:={fn:function(Expr,Sequence):Expr,hash:int,env:Sequence};
     import Sequence:=array(Expr);
     import Frame:={next:Frame,scopenum:int,values:Sequence};
     import dummyFrame:Frame;
     import FunctionClosure:={frame:Frame,model:functionCode};
     import SymbolClosure:={frame:Frame,symbol:Symbol};
     import List:={class:Object,v:Sequence,hash:int,mutable:bool};
     import Error:={position:Position,message:string,report:Expr};
     import Handle:={handle:int};
     import Database:={filename:string,hash:int,handle:int,isopen:bool,mutable:bool};
     import Boolean:={v:bool};
     import Nothing:={nothing:void};
     import Expr:=(Real or Boolean or file or string or FunctionClosure or Error or Sequence or CompiledFunction or CompiledFunctionClosure or SymbolClosure or List or Rational or Integer or Object or Handle or Database or Nothing or Net);
     import fun:=function(Expr):Expr;
     import True:Expr;
     import False:Expr;
     import toBoolean(v:bool):Expr;
     import nullE:Expr;
     import exprCode:={v:Expr,position:Position};
     import variableCode:={v:Symbol,position:Position};
     import CodeSequence:=array(Code);
     import unaryCode:={f:unop,rhs:Code,position:Position};
     import binaryCode:={f:binop,lhs:Code,rhs:Code,position:Position};
     import ternaryCode:={f:ternop,arg1:Code,arg2:Code,arg3:Code,position:Position};
     import multaryCode:={f:multop,args:CodeSequence,position:Position};
     import unop:=function(Code):Expr;
     import binop:=function(Code,Code):Expr;
     import ternop:=function(Code,Code,Code):Expr;
     import multop:=function(CodeSequence):Expr;
     import openScopeCode:={scope:Scope,body:Code};
     import functionDescription:={scopenum:int,framesize:int,numparms:int,restargs:bool,hasClosure:bool};
     import dummyDesc:functionDescription;
     import functionCode:={parms:Code,body:Code,desc:functionDescription};
     import Code:=(exprCode or variableCode or unaryCode or binaryCode or ternaryCode or multaryCode or CodeSequence or openScopeCode or functionCode);
     import newDictionary():Dictionary;
     import ScopeList:=(null or ScopeListCell);
     import ScopeListCell:={scope:Scope,next:ScopeList};
     import allScopes:ScopeList;
     import numScopes:int;
     import globalScope:Scope;
     import globalFrame:Frame;
     import localFrame:Frame;
     import newScope(scope:Scope):Scope;
     import KeyValuePair:={key:Expr,hash:int,value:Expr,next:KeyValuePair};
     import Object:={table:array(KeyValuePair),class:Object,parent:Object,numEntries:int,hash:int,mutable:bool};
     import HashCounter:int;
     import nextHash():int;
     import dummyWord:Word;
     import dummyDictionary:Dictionary;
     import dummyTree:ParseTree;
     import dummyCode:Code;
     import emptySequence:Sequence;
     import dummyUnaryFun(c:Code):Expr;
     import dummyPostfixFun(c:Code):Expr;
     import dummyBinaryFun(c:Code,d:Code):Expr;
     import dummyTernaryFun(c:Code,d:Code,e:Code):Expr;
     import dummyMultaryFun(c:CodeSequence):Expr;
     import emptynullE:Expr;
     import bucketEnd:KeyValuePair;
     import thingClass:Object;
     import dummySymbol:Symbol;
     import dummyToken:Token;
     import parseEOL:parseinfo;
     import parseEOF:parseinfo;
     import parseWORD:parseinfo;
     import parseERRMSG:parseinfo;
     import ExprEmptySequence:Expr;
     import cleanfun:function(Object):void;
     import newobject(class:Object,parent:Object):Object;
     import objectClass:Object;
     import mutableObjectClass:Object;
     import typeClass:Object;
     import basicListClass:Object;
     import mutableListClass:Object;
     import listClass:Object;
     import timeClass:Object;
     import fileClass:Object;
     import stringClass:Object;
     import functionClass:Object;
     import symbolClass:Object;
     import errorClass:Object;
     import handleClass:Object;
     import netClass:Object;
     import booleanClass:Object;
     import dbClass:Object;
     import sequenceClass:Object;
     import symboltableClass:Object;
     import arrayClass:Object;
     import ringClass:Object;
     import integerClass:Object;
     import fieldClass:Object;
     import rationalClass:Object;
     import doubleClass:Object;
     import emptyClass:Object;
     import op===(x:SymbolClosure,y:SymbolClosure):bool;
     import op===(x:Symbol,y:SymbolClosure):bool;
     import op===(x:SymbolClosure,y:Symbol):bool;
     import op===(x:SymbolClosure,y:Expr):bool;
     import op===(x:Expr,y:SymbolClosure):bool;
     import op===(x:Symbol,y:Expr):bool;
     import op===(x:Expr,y:Symbol):bool;
);
